% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/class-runtime.R
\name{AgentRuntime}
\alias{AgentRuntime}
\title{Agent Runtime Environment for State Execution}
\description{
R6 class that provides an isolated execution environment for
agent execution. Contains references to the executing agent (who), the
context (where), and the policy (what). This class is instantiated
per-execution and passed to agents, enabling
\verb{async}-safe execution without
relying on global state.
}
\details{
\subsection{Purpose}{

The runtime serves three main purposes:
\enumerate{
\item \strong{\verb{Async} safety}: Captures execution context
in closures, avoiding race conditions with global state when agents
execute concurrently
\item \strong{Simplified API}: Agents receive a single \code{runtime}
argument instead of separate \code{agent}, \code{policy},
\code{context} arguments
\item \strong{Tool injection}: \verb{MCP} tools that declare a
\code{.runtime} parameter receive the runtime automatically via
closure capture at \verb{instantiation} time
}
}

\subsection{Tool Runtime Injection}{

When \code{\link{mcptool_instantiate}} creates tool wrappers, it checks if
the underlying function has a \code{.runtime} formal parameter. If so, the
runtime is automatically injected into calls. This allows downstream
packages to create \verb{MCP} tools that access the execution context:

\preformatted{
my_mcp_tool <- function(arg1, arg2, .runtime = NULL) {
  if (!is.null(.runtime)) {
    .runtime$logger("Tool called with runtime access")
    ctx <- .runtime$context
  }
  # ... tool implementation
}
}
}
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{agent}}{\code{\link{Agent}} object, the agent being executed (who)}

\item{\code{context}}{\code{\link{AgentContext}} object, the execution
context (where)}

\item{\code{policy}}{\code{\link{StatePolicy}} object, the policy being
executed (what)}

\item{\code{attempt}}{integer, retry count if failed}

\item{\code{attachment_id}}{character, attachment prefix}

\item{\code{id}}{character, short identifier for this execution to show
in the context logs}

\item{\code{master_policy}}{\code{\link{MasterPolicy}} object,
the master-level policy (global parameters)}

\item{\code{status}}{character, current runtime status
(\code{"idle"}, \code{"running"}, or \code{"completed"})}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-TricobblerAgentRuntime-new}{\code{AgentRuntime$new()}}
\item \href{#method-TricobblerAgentRuntime-logger}{\code{AgentRuntime$logger()}}
\item \href{#method-TricobblerAgentRuntime-get_parameter}{\code{AgentRuntime$get_parameter()}}
\item \href{#method-TricobblerAgentRuntime-run_async}{\code{AgentRuntime$run_async()}}
\item \href{#method-TricobblerAgentRuntime-run}{\code{AgentRuntime$run()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerAgentRuntime-new"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerAgentRuntime-new}{}}}
\subsection{Method \code{new()}}{
Initialize a new runtime environment
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AgentRuntime$new(agent, context, policy, attempt = 0L, master_policy = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{agent}}{\code{\link{Agent}} object being executed}

\item{\code{context}}{\code{\link{AgentContext}} object for logging and storage}

\item{\code{policy}}{\code{\link{StatePolicy}} object being executed}

\item{\code{attempt}}{integer, retry count (default: \code{0L})}

\item{\code{master_policy}}{\code{\link{MasterPolicy}} object (optional),
provides global parameters that cascade to agents}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerAgentRuntime-logger"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerAgentRuntime-logger}{}}}
\subsection{Method \code{logger()}}{
Log a message with the agent as caller
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AgentRuntime$logger(
  ...,
  level = c("INFO", "TRACE", "DEBUG", "WARN", "ERROR", "FATAL"),
  verbose = c("cli", "base", "none"),
  public = TRUE,
  role = NA_character_
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{character, message components to paste together}

\item{\code{level}}{character, log level (INFO, WARN, ERROR, FATAL, DEBUG)}

\item{\code{verbose}}{character or logical, verbosity setting}

\item{\code{public}}{logical, whether to also log to the context log}

\item{\code{role}}{character, role label for the log entry}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
NULL invisibly
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerAgentRuntime-get_parameter"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerAgentRuntime-get_parameter}{}}}
\subsection{Method \code{get_parameter()}}{
Retrieve a parameter by name with cascading lookup.

When \code{levels = "cascade"} (default), looks first in the
state-level policy parameters (\code{policy@parameters$args}),
then falls back to the master-level policy parameters
(\code{master_policy@parameters}). Use \code{"local"} or
\code{"global"} to restrict the search scope.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AgentRuntime$get_parameter(
  key,
  missing = NULL,
  levels = c("cascade", "global", "local")
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{key}}{character, the parameter name to look up}

\item{\code{missing}}{default value to return when the key is not
found at the requested level(s) (default: \code{NULL})}

\item{\code{levels}}{character, lookup scope: \code{"cascade"}
(local then global), \code{"local"} (state policy only), or
\code{"global"} (master policy only)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The parameter value, or \code{missing} if not found.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerAgentRuntime-run_async"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerAgentRuntime-run_async}{}}}
\subsection{Method \code{run_async()}}{
Execute the agent asynchronously, returning a
\code{promises::promise} that resolves with the recorded attachment
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AgentRuntime$run_async()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A \code{promises::promise} object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerAgentRuntime-run"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerAgentRuntime-run}{}}}
\subsection{Method \code{run()}}{
Execute the agent synchronously, blocking
until completion and returning the recorded attachment
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AgentRuntime$run()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
The attachment list (invisibly)
}
}
}

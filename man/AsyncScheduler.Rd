% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/class-scheduler_async.R
\name{AsyncScheduler}
\alias{AsyncScheduler}
\title{Workflow Execution Scheduler}
\description{
R6 class that orchestrates workflow execution by managing stage
progression, state execution, and agent coordination. This is the primary
runtime component in the Runtime Layer (Tier 2) that brings together the
immutable policy definitions (\code{Manifest}) with executable agents.
}
\details{
The scheduler uses a queue + waiting-pool dispatch model.
Within each stage, independent states are dispatched concurrently
via \code{AgentRuntime$run_async()}, bounded by
\code{max_concurrency}. Stages themselves are executed
sequentially.

\describe{
\item{\code{start()}}{Blocks until all stages complete (runs the
event loop inline).}
\item{\code{start_async()}}{Returns a promise that resolves when
all stages complete.}
\item{\code{run_stage(stage)}}{Executes a single named stage
using the queue + pool model. Returns a promise
(\code{coro::async}).}
}
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{manifest}}{Manifest, the workflow blueprint}

\item{\code{agents}}{\code{fastmap::fastmap()} object, registry of Agent
objects keyed by agent_id}

\item{\code{context}}{Context, the execution environment for logging and storage}

\item{\code{current_stage}}{character, the currently executing stage name}

\item{\code{stage_started}}{\code{POSIXct}, timestamp when current stage started}

\item{\code{suspended}}{logical, whether execution is paused}

\item{\code{suspend_info}}{list or \code{NULL}, context captured when
the scheduler suspends (state_name, stage, error). Cleared
on resume/skip.}

\item{\code{draining}}{logical, when \code{TRUE} a \code{final} state
has completed; no new runtimes are dispatched but in-flight
promises are allowed to finish}

\item{\code{max_concurrency}}{integer, maximum number of simultaneous
promises in the waiting pool (default: \code{100L})}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-TricobblerAsyncScheduler-new}{\code{AsyncScheduler$new()}}
\item \href{#method-TricobblerAsyncScheduler-on}{\code{AsyncScheduler$on()}}
\item \href{#method-TricobblerAsyncScheduler-off}{\code{AsyncScheduler$off()}}
\item \href{#method-TricobblerAsyncScheduler-dispatch_event}{\code{AsyncScheduler$dispatch_event()}}
\item \href{#method-TricobblerAsyncScheduler-validate}{\code{AsyncScheduler$validate()}}
\item \href{#method-TricobblerAsyncScheduler-stop}{\code{AsyncScheduler$stop()}}
\item \href{#method-TricobblerAsyncScheduler-start}{\code{AsyncScheduler$start()}}
\item \href{#method-TricobblerAsyncScheduler-init_resources}{\code{AsyncScheduler$init_resources()}}
\item \href{#method-TricobblerAsyncScheduler-init_stage}{\code{AsyncScheduler$init_stage()}}
\item \href{#method-TricobblerAsyncScheduler-enqueue_runtime}{\code{AsyncScheduler$enqueue_runtime()}}
\item \href{#method-TricobblerAsyncScheduler-execute_runtime}{\code{AsyncScheduler$execute_runtime()}}
\item \href{#method-TricobblerAsyncScheduler-retry_runtime}{\code{AsyncScheduler$retry_runtime()}}
\item \href{#method-TricobblerAsyncScheduler-start_stage}{\code{AsyncScheduler$start_stage()}}
\item \href{#method-TricobblerAsyncScheduler-get_incomplete_size}{\code{AsyncScheduler$get_incomplete_size()}}
\item \href{#method-TricobblerAsyncScheduler-advance}{\code{AsyncScheduler$advance()}}
\item \href{#method-TricobblerAsyncScheduler-run_stage}{\code{AsyncScheduler$run_stage()}}
\item \href{#method-TricobblerAsyncScheduler-suspend}{\code{AsyncScheduler$suspend()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerAsyncScheduler-new"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerAsyncScheduler-new}{}}}
\subsection{Method \code{new()}}{
Initialize scheduler with manifest blueprint and agents
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AsyncScheduler$new(manifest, agents = list(), context = AgentContext$new())}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{manifest}}{Manifest object, the workflow blueprint}

\item{\code{agents}}{list, collection of Agent objects}

\item{\code{context}}{Context object, execution environment
(default: new \code{\link{AgentContext}})}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerAsyncScheduler-on"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerAsyncScheduler-on}{}}}
\subsection{Method \code{on()}}{
Register a listener for a lifecycle event
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AsyncScheduler$on(type, handler, id = NULL, after = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{type}}{character, event type (e.g. \code{"suspend"},
\code{"state_completed"}, \code{"stage_completed"},
\code{"dispatch"})}

\item{\code{handler}}{function, callback receiving the event list.
For \code{"suspend"} events the handler may return an action
string (\code{"resume"}, \code{"skip"}, \code{"abort"}, or
\code{"restart_stage"}).}

\item{\code{id}}{character or \code{NULL}, optional listener ID for
replacement or removal; auto-generated via
\code{digest::digest(handler)} when \code{NULL}}

\item{\code{after}}{logical, if \code{TRUE} (default) append the handler
after existing handlers; if \code{FALSE} prepend it}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
character, the listener ID (invisibly)
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerAsyncScheduler-off"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerAsyncScheduler-off}{}}}
\subsection{Method \code{off()}}{
Remove a registered lifecycle listener by ID
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AsyncScheduler$off(id)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{character, the listener ID returned by \code{$on()}}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerAsyncScheduler-dispatch_event"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerAsyncScheduler-dispatch_event}{}}}
\subsection{Method \code{dispatch_event()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AsyncScheduler$dispatch_event(type, message = type, ...)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerAsyncScheduler-validate"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerAsyncScheduler-validate}{}}}
\subsection{Method \code{validate()}}{
Verify that all required agents are registered
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AsyncScheduler$validate(on_error = c("error", "quiet"))}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{on_error}}{character, action on validation failure
("error" or "quiet")}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerAsyncScheduler-stop"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerAsyncScheduler-stop}{}}}
\subsection{Method \code{stop()}}{
Stop the workflow execution, clearing all
in-progress work and invalidating outstanding promises.
After calling \code{stop()}, the scheduler is in the
\code{"ready"} state and \code{start()} may be called
immediately.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AsyncScheduler$stop()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerAsyncScheduler-start"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerAsyncScheduler-start}{}}}
\subsection{Method \code{start()}}{
Start the workflow execution
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AsyncScheduler$start()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A \code{promise} that resolves when all stages complete.
Callers may block on the result via \code{later::run_now()}
or \code{await()} inside a \code{coro::async} context.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerAsyncScheduler-init_resources"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerAsyncScheduler-init_resources}{}}}
\subsection{Method \code{init_resources()}}{
Initialize resources and prepare for execution
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AsyncScheduler$init_resources(reset_context = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{reset_context}}{logical, whether to reset the context storage}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerAsyncScheduler-init_stage"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerAsyncScheduler-init_stage}{}}}
\subsection{Method \code{init_stage()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AsyncScheduler$init_stage(stage)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerAsyncScheduler-enqueue_runtime"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerAsyncScheduler-enqueue_runtime}{}}}
\subsection{Method \code{enqueue_runtime()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AsyncScheduler$enqueue_runtime()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerAsyncScheduler-execute_runtime"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerAsyncScheduler-execute_runtime}{}}}
\subsection{Method \code{execute_runtime()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AsyncScheduler$execute_runtime()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerAsyncScheduler-retry_runtime"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerAsyncScheduler-retry_runtime}{}}}
\subsection{Method \code{retry_runtime()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AsyncScheduler$retry_runtime()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerAsyncScheduler-start_stage"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerAsyncScheduler-start_stage}{}}}
\subsection{Method \code{start_stage()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AsyncScheduler$start_stage(stage)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerAsyncScheduler-get_incomplete_size"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerAsyncScheduler-get_incomplete_size}{}}}
\subsection{Method \code{get_incomplete_size()}}{
Count incomplete work items for the current stage
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AsyncScheduler$get_incomplete_size()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
integer, total items across runtime_map, ready_queue,
waiting_pool, and retry_map
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerAsyncScheduler-advance"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerAsyncScheduler-advance}{}}}
\subsection{Method \code{advance()}}{
Drive the next dispatch cycle (event-driven)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AsyncScheduler$advance()}\if{html}{\out{</div>}}
}

\subsection{Details}{
Called automatically when a runtime promise resolves.
Runs the cycle: \code{retry_runtime} -> \code{enqueue_runtime}
-> \code{execute_runtime}. If no incomplete work remains,
resolves the stage promise and emits \code{stage.completed}.
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerAsyncScheduler-run_stage"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerAsyncScheduler-run_stage}{}}}
\subsection{Method \code{run_stage()}}{
Execute a single workflow stage using the
queue + waiting-pool dispatch model
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AsyncScheduler$run_stage(stage)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{stage}}{character, the stage name to execute}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A promise that resolves when all states in the stage
have completed
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerAsyncScheduler-suspend"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerAsyncScheduler-suspend}{}}}
\subsection{Method \code{suspend()}}{
Suspend the workflow execution
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AsyncScheduler$suspend(
  error = NULL,
  state_name = NA_character_,
  stage = self$current_stage,
  runtime_summary = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{error}}{condition or character, the error that caused
suspension (default: \code{private$.last_error})}

\item{\code{state_name}}{character, the state that caused suspension}

\item{\code{stage}}{character, the stage in which suspension occurred
(default: \code{self$current_stage})}

\item{\code{runtime_summary}}{list or \code{NULL}, lightweight summary
of the runtime that failed (policy, agent, attempt,
attachment_id). Used by \code{"resume"} to re-create the
runtime and by \code{"skip"} to record the skipped state.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
character, the chosen action (invisibly)
}
}
}

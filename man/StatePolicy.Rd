% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/class-policystate.R
\name{StatePolicy}
\alias{StatePolicy}
\title{State-Level Policy Implementation for Workflow Stages}
\usage{
StatePolicy(
  name = character(0),
  description = character(0),
  stage = character(0),
  agent_id = character(0),
  resources = character(0),
  accessibility = "all",
  parameters = list(),
  max_retry = 0L,
  priority = 100L,
  critical = FALSE,
  final = FALSE,
  on_failure = NA_character_,
  depends_on = StateDeps()
)
}
\arguments{
\item{name}{character, name of the state policy (non-blank)}

\item{description}{character, human-readable description}

\item{stage}{character, must be a non-blank single string}

\item{agent_id}{character, unique identifier for the agent responsible for
executing this state. Must contain only letters, digits, underscores, or
dashes}

\item{resources}{character vector, tools that the agent may call during
execution (default empty vector)}

\item{accessibility}{character, context accessibility level for the agent.
Controls what context data the agent can read. One of \code{"all"}
(full access), \code{"logs"} (logs only), \code{"none"} (no access), or
\code{"explicit"} (use \code{depends_on} to specify inputs; if
\code{depends_on} is empty, behaves like \code{"logs"}).
Default is \code{"all"}}

\item{parameters}{list, state-specific parameters passed to the agent.
See \strong{Parameters for Different Agent Types} in Details}

\item{max_retry}{integer, maximum total attempts (initial + retries) for
this state during stage execution (default 0, meaning single attempt).
The \code{max_retry} limit applies globally across all re-entries to this
state within the same stage. If \code{on_failure} is set, this state will
not retry locally but will jump to the failure handler immediately. If
\code{on_failure} is NA, local retries up to \code{max_retry} will be
attempted before moving to next state}

\item{priority}{integer, execution priority (0-999, default 100). Higher
values run first (999 = highest priority, 0 = lowest). Used when multiple
states share the same stage. NA or NULL are treated as 100}

\item{critical}{logical, if TRUE, states with lower priority will not
execute if this state fails (default FALSE). Critical states must have
priority >= 1 and cannot share priority code with other states}

\item{final}{logical, if TRUE and validation succeeds, skip remaining states
in the workflow (default FALSE)}

\item{on_failure}{character, name of the state to jump to on first failure
(default NA to retry locally up to \code{max_retry} times). When set,
failures trigger immediate jump to the specified state without local
retries. The \code{max_retry} limit still applies globally to prevent
infinite loops: if this state is re-entered and total attempts exceed
\code{max_retry}, execution stops with an error. Common patterns:
validation loops (\code{on_failure = "executor"}), alternative strategies
(\code{on_failure = "slower_alternative"}), or repair chains
(\code{on_failure = "repair_step"})}

\item{depends_on}{\code{StateDeps} object or named list specifying explicit
dependencies on prior state outputs. Each entry maps a parameter name to
a dependency: \code{list(param = list(state = "state_name", field =
  "result", stage = NULL))}. Used with \code{accessibility = "explicit"}
for \verb{async} execution. See \code{\link{StateDeps}} for format details}
}
\description{
Represents a single workflow state. Inherits from \code{BasePolicy}
and adds a mandatory \code{stage} that must match one of the stages defined in a
\code{MasterPolicy}. Includes priority and criticality flags for execution
ordering when multiple states share the same stage.
}
\details{
\subsection{Stages vs States}{
\itemize{
\item \strong{Stage} (macro): The workflow phase name from \code{MasterPolicy@stages}
(e.g., "executing")
\item \strong{State} (micro): A concrete \code{StatePolicy} implementation of that
stage
\item Multiple states can reference the same stage for different execution
patterns
}
}

\subsection{Priority System and Execution Patterns}{

When multiple states share the same stage, execution pattern depends on
priority:
\itemize{
\item \strong{Range}: 0 (lowest) to 999 (highest)
\item \strong{Default}: 100 (when \code{priority = NA} or \code{NULL})
\item \strong{Execution order}: States run sequentially by priority (higher first)
}
}

\subsection{Critical Flag: Enforcing Sequential Execution}{

The \code{critical} flag enforces \strong{sequential} execution with fail-fast
semantics:
\itemize{
\item If \code{critical = TRUE}, this state \strong{must} execute and succeed before any
lower-priority states in the same stage can run
\item If a critical state fails, lower-priority states are skipped entirely
\item Critical states must have unique priority (enforced by \code{Manifest})
\item Critical states must have \code{priority >= 1} (cannot be lowest priority 0)
\item Critical states cannot share their priority value with other states in the
same stage (enforced by \code{Manifest} validation)
\item \strong{Use case}: Required validation gates that must pass before
alternatives run
}
}

\subsection{When to Use Multiple States Per Stage}{

Create multiple \code{StatePolicy} objects for the same stage when you need:
\enumerate{
\item \strong{Fallback chains}: Different priorities create ordered
execution with alternative strategies
\item \strong{Alternative implementations}: Multiple states for the same stage
execution with alternative strategies
(e.g., primary approach -> fallback -> last resort)
\item \strong{Critical validation gates}: Critical state must succeed before
lower-priority alternatives execute (enforces sequential, fail-fast
semantics)
\item \strong{Phased deployment}: Gradually shift priority as new implementations
mature
}
}

\subsection{Parameters for Different Agent Types}{

The \code{parameters} list is interpreted differently based on the agent
type created via \code{\link{as_agent}}:

\strong{Deterministic Agents} (from functions or \verb{MCP} tools):
\itemize{
\item \code{args}: list, function arguments passed via
\code{do.call(fun, args)}. Kept separate from other parameters to
avoid conflicts with functions that have their own reserved arguments
}

The \code{accessibility} property affects how inputs are constructed:
\itemize{
\item \code{"all"}: First argument is the previous agent's result
(\code{last_attachment$result}), followed by \code{args}
\item \code{"logs"}: First argument is the previous agent's description
(\code{last_attachment$description}), followed by \code{args}
\item \code{"none"}: Only \code{args} are passed (no context access)
}

\strong{Debug Mode}: Set \code{context$debug <- TRUE} at runtime to enable
debug mode. In debug mode, agents print their calls/tools for inspection
but run as no-op (returning debug information instead of executing).

\strong{AI Agents} (from \pkg{ellmer} Chat objects):
\itemize{
\item \code{system_prompt}: character, additional system prompt appended
to \code{@description}
\item \code{user_prompt}: character, the user message
to send to the \verb{LLM}
\item \code{keep_turns}: logical, if \code{TRUE}, retains conversation
history across executions (default \code{FALSE})
\item \code{return_type}: an \pkg{ellmer} type indicator (e.g.,
\code{ellmer::type_object()}). When provided, triggers
\code{chat$chat_structured(type = return_type)} for structured output.
Can also be specified in YAML via \code{map_type_to_ellmer()}
}
}
}
\examples{

# Basic state
StatePolicy(
  name = "state1",
  stage = "idle",
  description = "initial idle state",
  agent_id = "agent1",
  parameters = list()
)

# Critical high-priority state
StatePolicy(
  name = "validator",
  stage = "executing",
  description = "critical validation step",
  agent_id = "validator_agent",
  priority = 900,
  critical = TRUE
)

# Deterministic agent with parameters
StatePolicy(
  name = "formatter",
  stage = "executing",
  description = "Format data to JSON",
  agent_id = "json_formatter",
  accessibility = "none",  # Only use args, no context
  parameters = list(
    args = list(x = list(a = 1, b = 2), pretty = TRUE)
  )
)

# AI agent with structured output
StatePolicy(
  name = "planner",
  stage = "planning",
  description = "Break down the task into steps",
  agent_id = "llm_planner",
  parameters = list(
    system_prompt = "You are a task planning expert.",
    user_prompt = "Plan the following task: ...",
    keep_turns = FALSE,
    return_type = ellmer::type_object(
      steps = ellmer::type_array(items = ellmer::type_string())
    )
  )
)


}

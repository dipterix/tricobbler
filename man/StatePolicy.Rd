% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/class-policy.R
\name{StatePolicy}
\alias{StatePolicy}
\title{State-Level Policy Implementation for Workflow Stages}
\usage{
StatePolicy(
  name = character(0),
  description = character(0),
  stage = character(0),
  agent_id = character(0),
  resources = character(0),
  parameters = list(),
  max_retry = 0L,
  priority = 100L,
  critical = FALSE,
  final = FALSE,
  on_failure = NA_character_
)
}
\arguments{
\item{name}{character, name of the state policy (non-blank)}

\item{description}{character, human-readable description}

\item{stage}{character, must be a non-blank single string}

\item{agent_id}{character, unique identifier for the agent responsible for
executing this state. Must contain only letters, digits, underscores, or
dashes}

\item{resources}{character vector, tools that the agent may call during
execution (default empty vector)}

\item{parameters}{list, optional state-specific parameters}

\item{max_retry}{integer, maximum total attempts (initial + retries) for
this state during stage execution (default 0, meaning single attempt).
The \code{max_retry} limit applies globally across all re-entries to this
state within the same stage. If \code{on_failure} is set, this state will
not retry locally but will jump to the failure handler immediately. If
\code{on_failure} is NA, local retries up to \code{max_retry} will be
attempted before moving to next state}

\item{priority}{integer, execution priority (0-999, default 100). Higher
values run first (999 = highest priority, 0 = lowest). Used when multiple
states share the same stage. NA or NULL are treated as 100}

\item{critical}{logical, if TRUE, states with lower priority will not
execute if this state fails (default FALSE). Critical states must have
priority >= 1 and cannot share priority code with other states}

\item{final}{logical, if TRUE and validation succeeds, skip remaining states
in the workflow (default FALSE)}

\item{on_failure}{character, name of the state to jump to on first failure
(default NA to retry locally up to \code{max_retry} times). When set,
failures trigger immediate jump to the specified state without local
retries. The \code{max_retry} limit still applies globally to prevent
infinite loops: if this state is re-entered and total attempts exceed
\code{max_retry}, execution stops with an error. Common patterns:
validation loops (\code{on_failure = "executor"}), alternative strategies
(\code{on_failure = "slower_alternative"}), or repair chains
(\code{on_failure = "repair_step"})}
}
\description{
Represents a single workflow state. Inherits from \code{BasePolicy}
and adds a mandatory \code{stage} that must match one of the stages defined in a
\code{MasterPolicy}. Includes priority and criticality flags for execution
ordering when multiple states share the same stage.
}
\details{
\subsection{Stages vs States}{
\itemize{
\item \strong{Stage} (macro): The workflow phase name from \code{MasterPolicy@stages}
(e.g., "executing")
\item \strong{State} (micro): A concrete \code{StatePolicy} implementation of that
stage
\item Multiple states can reference the same stage for different execution
patterns
}
}

\subsection{Priority System and Execution Patterns}{

When multiple states share the same stage, execution pattern depends on
priority:
\itemize{
\item \strong{Range}: 0 (lowest) to 999 (highest)
\item \strong{Default}: 100 (when \code{priority = NA} or \code{NULL})
\item \strong{Execution order}: States run sequentially by priority (higher first)
}
}

\subsection{Critical Flag: Enforcing Sequential Execution}{

The \code{critical} flag enforces \strong{sequential} execution with fail-fast
semantics:
\itemize{
\item If \code{critical = TRUE}, this state \strong{must} execute and succeed before any
lower-priority states in the same stage can run
\item If a critical state fails, lower-priority states are skipped entirely
\item Critical states must have unique priority (enforced by \code{Manifest})
\item Critical states must have \code{priority >= 1} (cannot be lowest priority 0)
\item Critical states cannot share their priority value with other states in the
same stage (enforced by \code{Manifest} validation)
\item \strong{Use case}: Required validation gates that must pass before
alternatives run
}
}

\subsection{When to Use Multiple States Per Stage}{

Create multiple \code{StatePolicy} objects for the same stage when you need:
\enumerate{
\item \strong{Fallback chains}: Different priorities create ordered
execution with alternative strategies
\item \strong{Alternative implementations}: Multiple states for the same stage
execution with alternative strategies
(e.g., primary approach -> fallback -> last resort)
\item \strong{Critical validation gates}: Critical state must succeed before
lower-priority alternatives execute (enforces sequential, fail-fast
semantics)
\item \strong{Phased deployment}: Gradually shift priority as new implementations
mature
}
}
}
\examples{

# Basic state
StatePolicy(
  name = "state1",
  stage = "idle",
  description = "initial idle state",
  agent_id = "agent1",
  parameters = list()
)

# Critical high-priority state
StatePolicy(
  name = "validator",
  stage = "executing",
  description = "critical validation step",
  agent_id = "validator_agent",
  priority = 900,
  critical = TRUE
)

}

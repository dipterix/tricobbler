% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/class-scheduler_sync.R
\name{Scheduler}
\alias{Scheduler}
\title{Synchronous Workflow Scheduler}
\description{
R6 class that orchestrates sequential execution of workflow
stages and states. Manages the \verb{lifecycle} of agent runtimes through
priority-based dispatch, dependency resolution, retry logic, and
critical-state suspension. This is the synchronous (blocking) scheduler;
see \code{\link{AsyncScheduler}} for the promise-based variant.
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{manifest}}{\code{\link{Manifest}}, the workflow blueprint}

\item{\code{agents}}{\code{fastmap::fastmap()} object, registry of
\code{\link{Agent}} objects keyed by \code{agent_id}}

\item{\code{context}}{\code{\link{AgentContext}}, the execution environment
for logging and storage}

\item{\code{current_stage}}{character, the currently executing stage name}

\item{\code{stage_started}}{\code{POSIXct} or \code{NULL}, timestamp when
the current stage started}

\item{\code{suspended}}{logical, whether execution is paused}

\item{\code{suspend_info}}{list or \code{NULL}, context captured when
the scheduler suspends (state_name, stage, error). Cleared
on resume/skip.}

\item{\code{draining}}{logical, when \code{TRUE} a \code{final} state
has completed; no new runtimes are dispatched and any
remaining queued items are abandoned}

\item{\code{max_concurrency}}{integer, maximum number of states to
dispatch per advance cycle (default: \code{100L})}

\item{\code{runtime_map}}{\code{fastmap::fastmap()} object, all runtimes
for the current stage before joining the ready queue}

\item{\code{ready_queue}}{\code{fastmap::fastqueue()} object, priority-sorted
queue of runtimes ready to execute}

\item{\code{waiting_pool}}{\code{fastmap::fastmap()} object, tracks
currently executing runtimes}

\item{\code{completed_map}}{\code{fastmap::fastmap()} object, maps
state names to completion records with status
(\code{"finished"}, \code{"errored"}, or \code{"skipped"})}

\item{\code{retry_map}}{\code{fastmap::fastmap()} object, maps state
names to integer attempt counts for retry scheduling}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-TricobblerScheduler-new}{\code{Scheduler$new()}}
\item \href{#method-TricobblerScheduler-on}{\code{Scheduler$on()}}
\item \href{#method-TricobblerScheduler-off}{\code{Scheduler$off()}}
\item \href{#method-TricobblerScheduler-dispatch_event}{\code{Scheduler$dispatch_event()}}
\item \href{#method-TricobblerScheduler-validate}{\code{Scheduler$validate()}}
\item \href{#method-TricobblerScheduler-stop}{\code{Scheduler$stop()}}
\item \href{#method-TricobblerScheduler-start}{\code{Scheduler$start()}}
\item \href{#method-TricobblerScheduler-init_resources}{\code{Scheduler$init_resources()}}
\item \href{#method-TricobblerScheduler-init_stage}{\code{Scheduler$init_stage()}}
\item \href{#method-TricobblerScheduler-enqueue_runtime}{\code{Scheduler$enqueue_runtime()}}
\item \href{#method-TricobblerScheduler-execute_runtime}{\code{Scheduler$execute_runtime()}}
\item \href{#method-TricobblerScheduler-retry_runtime}{\code{Scheduler$retry_runtime()}}
\item \href{#method-TricobblerScheduler-start_stage}{\code{Scheduler$start_stage()}}
\item \href{#method-TricobblerScheduler-get_incomplete_size}{\code{Scheduler$get_incomplete_size()}}
\item \href{#method-TricobblerScheduler-advance}{\code{Scheduler$advance()}}
\item \href{#method-TricobblerScheduler-run_stage}{\code{Scheduler$run_stage()}}
\item \href{#method-TricobblerScheduler-suspend}{\code{Scheduler$suspend()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerScheduler-new"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerScheduler-new}{}}}
\subsection{Method \code{new()}}{
Initialize scheduler with manifest blueprint and agents
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Scheduler$new(manifest, agents = list(), context = AgentContext$new())}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{manifest}}{\code{\link{Manifest}} object, the workflow blueprint}

\item{\code{agents}}{list, collection of \code{\link{Agent}} objects}

\item{\code{context}}{\code{\link{AgentContext}} object, execution environment
(default: new \code{\link{AgentContext}})}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerScheduler-on"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerScheduler-on}{}}}
\subsection{Method \code{on()}}{
Register a listener for a \verb{lifecycle} event
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Scheduler$on(type, handler, id = NULL, after = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{type}}{character, event type (e.g., \code{"suspend"},
\code{"runtime.resolved"}, \code{"stage.completed"},
\code{"runtime.dispatch"})}

\item{\code{handler}}{function, callback receiving the event list.
For \code{"suspend"} events the handler may return an action
string (\code{"resume"}, \code{"skip"}, \code{"abort"}, or
\code{"restart_stage"}).}

\item{\code{id}}{character or \code{NULL}, optional listener ID for
replacement or removal; auto-generated via
\code{digest::digest(handler)} when \code{NULL}}

\item{\code{after}}{logical, if \code{TRUE} (default) append the handler
after existing handlers; if \code{FALSE} prepend it}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
character, the listener ID (invisibly)
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerScheduler-off"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerScheduler-off}{}}}
\subsection{Method \code{off()}}{
Remove a registered \verb{lifecycle} listener by ID
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Scheduler$off(id)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{character, the listener ID returned by \code{$on()}}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerScheduler-dispatch_event"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerScheduler-dispatch_event}{}}}
\subsection{Method \code{dispatch_event()}}{
Emit a \verb{lifecycle} event to registered listeners
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Scheduler$dispatch_event(type, message = type, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{type}}{character, event type identifier}

\item{\code{message}}{character, human-readable event description}

\item{\code{...}}{additional named fields attached to the event}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerScheduler-validate"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerScheduler-validate}{}}}
\subsection{Method \code{validate()}}{
Verify that all required agents are registered
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Scheduler$validate(on_error = c("error", "quiet"))}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{on_error}}{character, action on validation failure:
\code{"error"} (throw an error) or \code{"quiet"} (return
\code{FALSE} silently)}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerScheduler-stop"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerScheduler-stop}{}}}
\subsection{Method \code{stop()}}{
Stop the workflow execution, clearing all
in-progress work and invalidating outstanding promises.
After calling \code{stop()}, the scheduler is in the
\code{"ready"} state and \code{start()} may be called
immediately.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Scheduler$stop()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerScheduler-start"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerScheduler-start}{}}}
\subsection{Method \code{start()}}{
Start the workflow execution
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Scheduler$start()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerScheduler-init_resources"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerScheduler-init_resources}{}}}
\subsection{Method \code{init_resources()}}{
Initialize resources and prepare for execution
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Scheduler$init_resources(reset_context = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{reset_context}}{logical, whether to reset the context storage}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerScheduler-init_stage"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerScheduler-init_stage}{}}}
\subsection{Method \code{init_stage()}}{
Initialize a single stage by creating runtimes
for all state policies in that stage
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Scheduler$init_stage(stage)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{stage}}{character, stage name to initialize}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerScheduler-enqueue_runtime"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerScheduler-enqueue_runtime}{}}}
\subsection{Method \code{enqueue_runtime()}}{
Move ready runtimes from \code{runtime_map} to the
\code{ready_queue} based on dependency satisfaction
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Scheduler$enqueue_runtime()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerScheduler-execute_runtime"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerScheduler-execute_runtime}{}}}
\subsection{Method \code{execute_runtime()}}{
Dispatch runtimes from \code{ready_queue} to
\code{waiting_pool} for execution (up to \code{max_concurrency})
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Scheduler$execute_runtime()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
integer, number of runtimes dispatched
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerScheduler-retry_runtime"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerScheduler-retry_runtime}{}}}
\subsection{Method \code{retry_runtime()}}{
Re-\verb{enqueue} runtimes from \code{retry_map} back into
\code{runtime_map} with incremented attempt counts
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Scheduler$retry_runtime()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerScheduler-start_stage"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerScheduler-start_stage}{}}}
\subsection{Method \code{start_stage()}}{
Prepare and validate a stage before execution
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Scheduler$start_stage(stage)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{stage}}{character, stage name to start}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerScheduler-get_incomplete_size"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerScheduler-get_incomplete_size}{}}}
\subsection{Method \code{get_incomplete_size()}}{
Count incomplete work items for the current stage
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Scheduler$get_incomplete_size()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
integer, total items across runtime_map, ready_queue,
waiting_pool, and retry_map
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerScheduler-advance"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerScheduler-advance}{}}}
\subsection{Method \code{advance()}}{
Drive the dispatch loop for the current stage.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Scheduler$advance()}\if{html}{\out{</div>}}
}

\subsection{Details}{
Loops synchronously: retry, \verb{enqueue}, then execute;
then checks for stage completion. Continues until no more
work remains or the stage is \verb{cancelled} or suspended.
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerScheduler-run_stage"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerScheduler-run_stage}{}}}
\subsection{Method \code{run_stage()}}{
Execute a single workflow stage using the
queue + waiting-pool dispatch model
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Scheduler$run_stage(stage)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{stage}}{character, the stage name to execute}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TricobblerScheduler-suspend"></a>}}
\if{latex}{\out{\hypertarget{method-TricobblerScheduler-suspend}{}}}
\subsection{Method \code{suspend()}}{
Suspend the workflow execution
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Scheduler$suspend(
  error = NULL,
  state_name = NA_character_,
  stage = self$current_stage,
  runtime_summary = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{error}}{condition or character, the error that caused
suspension (default: \code{private$.last_error})}

\item{\code{state_name}}{character, the state that caused suspension}

\item{\code{stage}}{character, the stage in which suspension occurred
(default: \code{self$current_stage})}

\item{\code{runtime_summary}}{list or \code{NULL}, lightweight summary
of the runtime that failed (policy, agent, attempt,
attachment_id). Used by \code{"resume"} to re-create the
runtime and by \code{"skip"} to record the skipped state.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
character, the chosen action (invisibly)
}
}
}

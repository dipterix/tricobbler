<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en-US"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>TriCobbler Async Architecture TODO • tricobbler</title><script src="deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet"><link href="deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet"><script src="deps/headroom-0.11.0/headroom.min.js"></script><script src="deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="deps/search-1.0.0/fuse.min.js"></script><script src="deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="pkgdown.js"></script><meta property="og:title" content="TriCobbler Async Architecture TODO"></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="index.html">tricobbler</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.0.0.9000</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="nav-item"><a class="nav-link" href="reference/index.html">Reference</a></li>
      </ul><ul class="navbar-nav"><li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="search.json"></form></li>
      </ul></div>


  </div>
</nav><div class="container template-title-body">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>TriCobbler Async Architecture TODO</h1>

    </div>

<div id="tricobbler-async-architecture-todo" class="section level1">

<p>This document outlines the implementation plan for async/parallel execution support in tricobbler.</p>
<div class="section level2">
<h2 id="overview">Overview<a class="anchor" aria-label="anchor" href="#overview"></a></h2>
<p><strong>Goal:</strong> Enable concurrent agent execution using R promises, allowing multiple LLM calls to run simultaneously without blocking. Each agent should return a <code>promise</code> object</p>
<p><strong>Architecture Decision:</strong> Use <code>coro</code> + <code>promises</code> (not <code>future</code>) because: - LLM agents are I/O-bound (waiting for API responses), not CPU-bound - Single-process async avoids serialization overhead of multi-process approaches - <code><a href="https://ellmer.tidyverse.org/reference/Chat.html" class="external-link">ellmer::Chat</a></code> supports <code>chat$chat_async()</code>, <code>chat$stream_async()</code>, <code>chat$chat_structured_async()</code> returning promises - <code>chat$clone()</code> is supported for parallel Chat agent isolation - Simpler thread-safety model (single event loop vs file locking)</p>
<hr></div>
<div class="section level2">
<h2 id="phase-1-foundation---explicit-dependencies-done">Phase 1: Foundation - Explicit Dependencies [Done]<a class="anchor" aria-label="anchor" href="#phase-1-foundation---explicit-dependencies-done"></a></h2>
<p><strong>Why:</strong> Current <code>last_results(1)</code> returns chronologically last result. With parallel execution, result order is non-deterministic. Agents must explicitly declare which states they depend on.</p>
<div class="section level3">
<h3 id="id_11-add-depends_on-property-to-statepolicy">1.1 Add <code>depends_on</code> Property to StatePolicy<a class="anchor" aria-label="anchor" href="#id_11-add-depends_on-property-to-statepolicy"></a></h3>
<p><strong>Location:</strong> <code>R/class-policy.R</code></p>
<p><strong>Steps:</strong> 1. Add new S7 property to <code>StatePolicy</code>: <code>r    depends_on = S7::new_property(      class = StateDeps,  # Implemented as separate S7 class      default = StateDeps()    )</code> 2. Each dependency entry should be a named list element (key = parameter name): - <code>state</code>: Name of the state this depends on (character) - <code>field</code>: What to extract - <code>"result"</code> or <code>"description"</code> (character) - <code>stage</code>: (Optional) Stage name if depending on earlier stage 3. Add validator to <code>StateDeps</code> to ensure entries have required fields (format) 4. Add validator to property <code>states</code> in <code>Manifest</code> to ensure the dependency entries are valid (logic) 5. Update <code><a href="reference/manifest-file.html">manifest_write()</a></code> and <code><a href="reference/manifest-file.html">manifest_read()</a></code> for serialization</p>
<p><strong>Example manifest:</strong></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">states</span><span class="kw">:</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="at">  </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> aggregator</span></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="at">    </span><span class="fu">stage</span><span class="kw">:</span><span class="at"> executing</span></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="at">    </span><span class="fu">priority</span><span class="kw">:</span><span class="at"> </span><span class="dv">50</span></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="at">    </span><span class="fu">agent_id</span><span class="kw">:</span><span class="at"> aggregator_agent</span></span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="at">    </span><span class="fu">accessibility</span><span class="kw">:</span><span class="at"> explicit</span></span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a><span class="at">    </span><span class="fu">depends_on</span><span class="kw">:</span></span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a><span class="at">      </span><span class="fu">validation_result</span><span class="kw">:</span></span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a><span class="at">        </span><span class="fu">state</span><span class="kw">:</span><span class="at"> validator</span></span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a><span class="at">        </span><span class="fu">field</span><span class="kw">:</span><span class="at"> result</span></span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a><span class="at">      </span><span class="fu">parsed_data</span><span class="kw">:</span></span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a><span class="at">        </span><span class="fu">state</span><span class="kw">:</span><span class="at"> parser</span></span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a><span class="at">        </span><span class="fu">field</span><span class="kw">:</span><span class="at"> result</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="id_12-add-accessibility--explicit-level">1.2 Add <code>accessibility = "explicit"</code> Level<a class="anchor" aria-label="anchor" href="#id_12-add-accessibility--explicit-level"></a></h3>
<p><strong>Location:</strong> <code>R/class-policy.R</code>, <code>R/class-baseagent.R</code></p>
<p><strong>Steps:</strong> 1. Update <code>accessibility</code> property validator to accept <code>"explicit"</code> value 2. Modify <code><a href="reference/as_agent.html">as_agent()</a></code> wrapper to handle <code>"explicit"</code> accessibility: - Build inputs from <code>depends_on</code> mapping instead of <code>last_results()</code> (for deterministic agents such as functions or MCP tools) - For AI agents, include the <code>depends_on</code> as its chat context (into user prompts, see item 3) - Use new <code>get_attachment_by_state()</code> method (see 1.3) 3. Keep <code>"all"</code>, <code>"logs"</code>, <code>"none"</code> working: - “none”: agent have no access to logs nor attachment; under this situation, <code>depends_on</code> only indicates that this agent should await for the dependents to finish, but cannot access their contents - “logs”: agent have access to logs and attachment list but not contents; under this situation, <code>depends_on</code> only indicates that this agent should await for the dependents to finish, but cannot access their contents - “explicit”: agent have access to logs, attachment list, but only with the attachments from <code>depends_on</code> list. The MCP tool to read attachments will not be provided. However, all the <code>depends_on</code> descriptions will be included in the user prompt - “all”: agent will be provided tools to access all logs and attachments, the user prompt also includes <code>depends_on</code> descriptions</p>
</div>
<div class="section level3">
<h3 id="id_13-add-get_attachment_by_state-to-context">1.3 Add <code>get_attachment_by_state()</code> to Context<a class="anchor" aria-label="anchor" href="#id_13-add-get_attachment_by_state-to-context"></a></h3>
<p><strong>Location:</strong> <code>R/class-context.R</code></p>
<p><strong>Steps:</strong> 1. Add new public method: <code>r    get_attachment_by_state = function(state, stage) {      # Find attachment matching state and stage      # Return most recent match if multiple exist (retries)    }</code> 2. Use <code>private$.results</code> index to locate attachment by state name 3. Load and return the attachment object</p>
<hr></div>
</div>
<div class="section level2">
<h2 id="phase-2-globals-isolation-done">Phase 2: Globals Isolation [Done]<a class="anchor" aria-label="anchor" href="#phase-2-globals-isolation-done"></a></h2>
<p><strong>Why:</strong> Current globals (<code>active_context</code>, <code>active_agent</code>, <code>active_policy</code>) in <code>R/aaa.R</code> are shared across all agents. With parallel execution, concurrent agents overwrite each other’s globals, causing MCP tools to receive wrong context.</p>
<div class="section level3">
<h3 id="id_21-create-agentruntime-class">2.1 Create AgentRuntime Class<a class="anchor" aria-label="anchor" href="#id_21-create-agentruntime-class"></a></h3>
<p><strong>Location:</strong> <code>R/class-runtime.R</code></p>
<p><strong>Implementation:</strong> 1. Created <code>AgentRuntime</code> R6 class with per-execution state: <code>r    AgentRuntime &lt;- R6::R6Class(      private = list(        .agent = NULL,        # Current Agent (who)        .context = NULL,      # AgentContext (where)        .policy = NULL,       # StatePolicy (what)        .execution_id = NULL  # Unique ID for this execution      ),      active = list(        agent = function() { private$.agent },        context = function() { private$.context },        policy = function() { private$.policy },        execution_id = function() { private$.execution_id }      ),      public = list(        logger = function(...) { ... },  # Convenience method        run = function(attempt) { ... },       # Sync execution        run_async = function(attempt) { ... }  # Async execution      )    )</code> 2. Runtime is instantiated per-execution in Scheduler and passed to agents 3. Encapsulates execution logic with <code>run()</code> and <code>run_async()</code> methods using <code><a href="https://coro.r-lib.org/reference/async.html" class="external-link">coro::async</a></code>/<code>await</code></p>
</div>
<div class="section level3">
<h3 id="id_22-update-mcp-tools-for-explicit-runtime">2.2 Update MCP Tools for Explicit Runtime<a class="anchor" aria-label="anchor" href="#id_22-update-mcp-tools-for-explicit-runtime"></a></h3>
<p><strong>Location:</strong> <code>R/mcp-tooldef-config.R</code>, <code>R/mcp-tooldef-context.R</code>, <code>R/mcp-tools.R</code></p>
<p><strong>Implementation:</strong> 1. Added <code>.runtime</code> parameter to all MCP tools: <code>r    mcp_tool_context_logs_tail &lt;- function(max_lines, skip_lines, .runtime = NULL) {      ctx &lt;- if (!is.null(.runtime)) .runtime$context else NULL      # ...    }</code> 2. <code><a href="reference/mcptool_instantiate.html">mcptool_instantiate()</a></code> detects <code>.runtime</code> parameter via <code><a href="https://rdrr.io/r/base/formals.html" class="external-link">formals()</a></code> inspection 3. Runtime is injected via closure capture at tool instantiation time: <code>r    mcptool_instantiate &lt;- function(tool, ..., runtime = NULL) {      has_runtime_param &lt;- ".runtime" %in% names(formals(impl))      wrapper_fun &lt;- function() {        if (has_runtime_param &amp;&amp; !is.null(runtime)) {          call[[".runtime"]] &lt;- runtime        }        # ...      }    }</code> 4. Removed globals infrastructure (<code>set_globals</code>, <code>get_globals</code>, <code>get_active_context</code>)</p>
</div>
<div class="section level3">
<h3 id="id_23-update-agent-function-signature">2.3 Update Agent Function Signature<a class="anchor" aria-label="anchor" href="#id_23-update-agent-function-signature"></a></h3>
<p><strong>Location:</strong> <code>R/class-baseagent.R</code></p>
<p><strong>Implementation:</strong> 1. Agent functions now require <code>runtime</code> as the first parameter: <code>r    function(runtime, ...) {      # runtime$agent - the Agent object itself      # runtime$policy - the StatePolicy being executed      # runtime$context - the Context for logging      # runtime$logger() - shorthand for logging    }</code> 2. Validator enforces <code>runtime</code> as first argument name 3. Scheduler creates runtime and calls <code>runtime$run()</code>, records results via <code><a href="https://rdrr.io/r/base/do.call.html" class="external-link">do.call()</a></code></p>
<hr></div>
</div>
<div class="section level2">
<h2 id="phase-3-per-runtime-logging--atomic-attachments-done">Phase 3: Per-Runtime Logging &amp; Atomic Attachments [Done]<a class="anchor" aria-label="anchor" href="#phase-3-per-runtime-logging--atomic-attachments-done"></a></h2>
<p><strong>Why:</strong> Each <code>AgentRuntime</code> owns its execution lifecycle completely—one runtime = one attempt = one attachment. Per-runtime log files enable crash inspection and clean separation of concerns without file locking (unnecessary since R promises/coro are single-threaded).</p>
<p><strong>Key insight:</strong> One <code>AgentRuntime</code> = one execution attempt = one attachment. The <code>attachment_id</code> (format <code>[stage][state][agent_id]_YYMMDDTHHMMSS_{attempt}</code>) is the primary key across log files, <code>.rds</code> attachments, and the SQLite index.</p>
<div class="section level3">
<h3 id="id_31-move-attempt-to-agentruntime-initializer-done">3.1 Move <code>attempt</code> to AgentRuntime Initializer [Done]<a class="anchor" aria-label="anchor" href="#id_31-move-attempt-to-agentruntime-initializer-done"></a></h3>
<p><strong>Location:</strong> <code>R/class-runtime.R</code></p>
<p><strong>Implementation:</strong> 1. <code>AgentRuntime$new(agent, context, policy, attempt = 0L)</code> — attempt is validated and stored at construction 2. <code>attachment_id</code> is generated immediately in the constructor: <code>r    private$.attachment_id &lt;- sprintf(      "[%s][%s][%s]_%s_%d",      policy@stage, policy@name, agent@id,      format(now, "%y%m%dT%H%M%S"), attempt    )</code> 3. Runtime registers itself in <code>AttachmentIndex</code> with status <code>"init"</code> at construction 4. <code>run()</code> and <code>run_async()</code> take no arguments — attempt is already known 5. Scheduler creates a fresh <code>AgentRuntime</code> per retry attempt, passing the cumulative retry count</p>
</div>
<div class="section level3">
<h3 id="id_32-per-runtime-log-file-done">3.2 Per-Runtime Log File [Done]<a class="anchor" aria-label="anchor" href="#id_32-per-runtime-log-file-done"></a></h3>
<p><strong>Location:</strong> <code>R/class-runtime.R</code></p>
<p><strong>Implementation:</strong> 1. <code>$logger(...)</code> writes to <code>{attachment_path}/{attachment_id}.log</code> via <code>log_to_file()</code>, and optionally mirrors to the main context log when running in the main process (<code><a href="https://rdrr.io/r/base/Sys.getpid.html" class="external-link">Sys.getpid()</a></code> check) 2. <code>$logger()</code> supports <code>level</code>, <code>verbose</code>, <code>public</code>, and <code>role</code> parameters — reuses the shared <code>log_to_file()</code> helper from <code>R/helper-logger.R</code> 3. No separate <code>$get_logs()</code> on runtime — context provides <code>$get_runtime_log(attachment_id)</code> instead</p>
</div>
<div class="section level3">
<h3 id="id_33-timing-capture--result-recording-done">3.3 Timing Capture &amp; Result Recording [Done]<a class="anchor" aria-label="anchor" href="#id_33-timing-capture--result-recording-done"></a></h3>
<p><strong>Location:</strong> <code>R/class-runtime.R</code></p>
<p><strong>Implementation:</strong> 1. <code>private$.create_run_impl()</code> captures <code>time_started &lt;- Sys.time()</code> at execution start and passes <code>started</code> and <code>duration</code> to <code>.record_result()</code> 2. <code>private$.record_result(result, succeed, ...)</code> handles all result finalization: - Calls <code>agent@describe(result)</code> for human-readable description - Saves <code>.rds</code> attachment to <code>{attachment_path}/{attachment_id}.rds</code> - Logs result summary: <code>Status=finished</code> or <code>Status=errored</code> - Calls <code>context$record_attachment(runtime, succeed)</code> to update index 3. Index status transitions: <code>init</code> → <code>running</code> (at execution start) → <code>finished</code>/<code>errored</code> (at result recording)</p>
</div>
<div class="section level3">
<h3 id="id_34-sqlite-backed-attachmentindex-done">3.4 SQLite-Backed AttachmentIndex [Done]<a class="anchor" aria-label="anchor" href="#id_34-sqlite-backed-attachmentindex-done"></a></h3>
<p><strong>Location:</strong> <code>R/class-attachment-index.R</code> (new file)</p>
<p><strong>Implementation:</strong> <code>AttachmentIndex</code> R6 class backed by RSQLite, replacing the previous text-based <code>.results</code> data.frame in <code>AgentContext</code>.</p>
<ol style="list-style-type: decimal"><li>
<p><strong>Schema:</strong></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode sql"><code class="sourceCode sql"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="kw">CREATE</span> <span class="kw">TABLE</span> attachment_index (</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>  attachment_id TEXT <span class="kw">PRIMARY</span> <span class="kw">KEY</span>,</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>  stage         TEXT <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a>  state         TEXT <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a>  agent_id      TEXT <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a>  attempt       <span class="dt">INTEGER</span> <span class="kw">NOT</span> <span class="kw">NULL</span> <span class="kw">DEFAULT</span> <span class="dv">0</span>,</span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a>  status        TEXT <span class="kw">NOT</span> <span class="kw">NULL</span> <span class="kw">DEFAULT</span> <span class="st">'init'</span>,</span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a>  succeed       <span class="dt">INTEGER</span>,</span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a>  created_at    <span class="dt">REAL</span> <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a>  updated_at    <span class="dt">REAL</span> <span class="kw">NOT</span> <span class="kw">NULL</span></span>
<span id="cb2-11"><a href="#cb2-11" tabindex="-1"></a>)</span></code></pre></div>
<p>Indexes on <code>(state, stage)</code> and <code>(status)</code> for common queries.</p>
</li>
<li><p><strong>Connection lifecycle:</strong> Open/close per operation via <code>private$.with_db(callback)</code> — negligible overhead for ~3-15 writes per scheduler run, and safe against connection leaks.</p></li>
<li><p><strong>Backend abstraction:</strong> All SQLite calls are isolated in <code>$.with_db()</code> and <code>$.init_db()</code>. To swap to duckdb or another backend, only these two private methods need modification.</p></li>
<li>
<p><strong>Public API:</strong></p>
<ul><li>
<code>$register(attachment_id, stage, state, agent_id, attempt)</code> — INSERT OR REPLACE with status <code>"init"</code>
</li>
<li>
<code>$update_status(attachment_id, status)</code> — set status to any of <code>init/running/finished/errored/skipped</code>
</li>
<li>
<code>$mark_finished(attachment_id, succeed)</code> — convenience: sets status + succeed flag</li>
<li>
<code>$get(attachment_id)</code> — single-row lookup</li>
<li>
<code>$list(status = NULL)</code> — all entries, most recent first, optional status filter</li>
<li>
<code>$query(state, stage, status)</code> — filter by state/stage/status</li>
<li>
<code>$list_incomplete(timeout_secs = NULL)</code> — entries with status <code>init</code> or <code>running</code>, optionally past a timeout</li>
<li>
<code>$exists(attachment_id)</code> — fast existence check</li>
<li>
<code>$get_db_path()</code> — returns the SQLite file path</li>
</ul></li>
<li><p><strong>Status lifecycle:</strong> <code>init</code> → <code>running</code> → <code>finished</code> | <code>errored</code> (and <code>skipped</code> reserved for future use)</p></li>
</ol></div>
<div class="section level3">
<h3 id="id_35-simplified-agentcontext-done">3.5 Simplified AgentContext [Done]<a class="anchor" aria-label="anchor" href="#id_35-simplified-agentcontext-done"></a></h3>
<p><strong>Location:</strong> <code>R/class-context.R</code></p>
<p><strong>Implementation:</strong> 1. <code>private$.results</code> (data.frame) replaced with <code>private$.index</code> (AttachmentIndex) 2. <code>init_resources()</code> creates <code>AttachmentIndex$new(db_path)</code> at <code>{attachment_path}/index.sqlite</code> 3. <code>$index</code> active binding exposes the index (read-only) 4. <code>record_attachment(runtime, succeed)</code> delegates to <code>index$mark_finished()</code> — logs <code>status=finished</code> or <code>status=errored</code> 5. <code>last_results()</code>, <code>get_attachment()</code>, <code>get_attachment_by_state()</code>, <code>list_attachments()</code> all query the index 6. New <code>$list_incomplete(timeout_secs)</code> — delegates to <code>index$list_incomplete()</code> 7. New <code>$get_runtime_log(attachment_id)</code> — reads <code>{attachment_path}/{attachment_id}.log</code></p>
</div>
<div class="section level3">
<h3 id="id_36-scheduler-integration-done">3.6 Scheduler Integration [Done]<a class="anchor" aria-label="anchor" href="#id_36-scheduler-integration-done"></a></h3>
<p><strong>Location:</strong> <code>R/class-scheduler.R</code></p>
<p><strong>Implementation:</strong> 1. Creates fresh <code>AgentRuntime$new(agent, context, policy, attempt = init_retry_count)</code> per attempt 2. Calls <code>runtime$run()</code> which internally handles the full lifecycle (init → running → record result → update index) 3. Retry logic remains in scheduler (<code>retry_map</code> tracks cumulative failure count per state) 4. Fixed bare <code>context</code> → <code>self$context</code> reference bug</p>
</div>
<div class="section level3">
<h3 id="id_37-bug-fixes-applied">3.7 Bug Fixes Applied<a class="anchor" aria-label="anchor" href="#id_37-bug-fixes-applied"></a></h3>
<ol style="list-style-type: decimal"><li>
<strong>Column name mismatch:</strong> <code>init_resources()</code> used <code>attachment_id</code> but <code>record_attachment()</code> used <code>filename</code> — fixed by SQLite schema where column names are defined once</li>
<li>
<strong>MCP fallback mismatch:</strong> Empty fallback data.frame used <code>current_attempt</code> but actual data used <code>attempt</code> — fixed by consistent schema</li>
<li>
<strong>Test references:</strong> All <code>$filename</code> references in tests updated to <code>$attachment_id</code>
</li>
<li>
<strong>RSQLite added to DESCRIPTION Imports</strong>, <code>@importFrom RSQLite SQLite</code> added to namespace</li>
</ol></div>
<div class="section level3">
<h3 id="dependencies-added">Dependencies Added<a class="anchor" aria-label="anchor" href="#dependencies-added"></a></h3>
<ul><li>
<code>RSQLite (&gt;= 2.3.0)</code> in DESCRIPTION Imports</li>
<li>
<code>R/class-attachment-index.R</code> added to Collate (before <code>class-context.R</code>)</li>
</ul><hr></div>
</div>
<div class="section level2">
<h2 id="phase-4-async-scheduler">Phase 4: Async Scheduler<a class="anchor" aria-label="anchor" href="#phase-4-async-scheduler"></a></h2>
<p><strong>Why:</strong> Enable concurrent execution of independent states within a priority level.</p>
<div class="section level3">
<h3 id="id_41-add-dependencies-to-description">4.1 Add Dependencies to DESCRIPTION<a class="anchor" aria-label="anchor" href="#id_41-add-dependencies-to-description"></a></h3>
<p><strong>Steps:</strong> 1. Add to Imports: <code>coro,    promises</code></p>
</div>
<div class="section level3">
<h3 id="id_42-implement-priority-grouped-execution">4.2 Implement Priority-Grouped Execution<a class="anchor" aria-label="anchor" href="#id_42-implement-priority-grouped-execution"></a></h3>
<p><strong>Location:</strong> <code>R/class-scheduler.R</code></p>
<p><strong>Strategy:</strong> - Group states by priority level - Execute priority groups sequentially (high to low) - Within each group, launch all states as promises concurrently - <code>await_all()</code> before moving to next priority level</p>
<p><strong>Steps:</strong> 1. Add <code>async</code> flag to <code>Scheduler$new()</code> and <code><a href="https://rdrr.io/r/stats/start.html" class="external-link">start()</a></code> 2. Create <code>run_stage_async()</code> method: ``<code>r    run_stage_async = coro::async(function(stage = NULL) {      states &lt;- extract_manifest_state(self$manifest, stage)      priority_groups &lt;- split(states, sapply(states,</code>@`, “priority”))</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode R"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a> <span class="cf">for</span> (priority <span class="cf">in</span> <span class="fu">sort</span>(<span class="fu">as.integer</span>(<span class="fu">names</span>(priority_groups)), <span class="at">decreasing =</span> <span class="cn">TRUE</span>)) {</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>   group <span class="ot">&lt;-</span> priority_groups[[<span class="fu">as.character</span>(priority)]]</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>   </span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a>   <span class="co"># Launch all same-priority states as promises</span></span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>   promises <span class="ot">&lt;-</span> <span class="fu">lapply</span>(group, <span class="cf">function</span>(policy) {</span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a>     self<span class="sc">$</span><span class="fu">run_state_async</span>(policy)</span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a>   })</span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a>   </span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a>   <span class="co"># AWAIT ALL before next priority level</span></span>
<span id="cb3-10"><a href="#cb3-10" tabindex="-1"></a>   results <span class="ot">&lt;-</span> coro<span class="sc">::</span><span class="fu">await_all</span>(promises)</span>
<span id="cb3-11"><a href="#cb3-11" tabindex="-1"></a>   </span>
<span id="cb3-12"><a href="#cb3-12" tabindex="-1"></a>   <span class="co"># Check for critical failures</span></span>
<span id="cb3-13"><a href="#cb3-13" tabindex="-1"></a>   <span class="cf">if</span> (<span class="fu">any_critical_failed</span>(results)) {</span>
<span id="cb3-14"><a href="#cb3-14" tabindex="-1"></a>     self<span class="sc">$</span><span class="fu">suspend</span>()</span>
<span id="cb3-15"><a href="#cb3-15" tabindex="-1"></a>     <span class="cf">break</span></span>
<span id="cb3-16"><a href="#cb3-16" tabindex="-1"></a>   }</span>
<span id="cb3-17"><a href="#cb3-17" tabindex="-1"></a> }</span></code></pre></div>
<p>}) ``<code>3. Create</code>run_state_async()<code>method that:    - Creates</code>ExecutionContext` for isolation - Calls agent with promise-returning pattern - Handles errors, records results</p>
</div>
<div class="section level3">
<h3 id="id_43-async-chat-agent-wrapper">4.3 Async Chat Agent Wrapper<a class="anchor" aria-label="anchor" href="#id_43-async-chat-agent-wrapper"></a></h3>
<p><strong>Location:</strong> <code>R/class-baseagent.R</code></p>
<p><strong>Steps:</strong> 1. Create <code>as_agent_from_chat_async()</code> variant: ```r agent_fun &lt;- coro::async(function(self, policy, context, exec_ctx) { # … prompt/tool setup …</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode R"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a> <span class="co"># ASYNC call</span></span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a> result_promise <span class="ot">&lt;-</span> <span class="cf">if</span> (<span class="sc">!</span><span class="fu">is.null</span>(return_type)) {</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>   chat<span class="sc">$</span><span class="fu">chat_structured_async</span>(messages, <span class="at">type =</span> return_type)</span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a> } <span class="cf">else</span> {</span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a>   chat<span class="sc">$</span><span class="fu">chat_async</span>(messages)</span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a> }</span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a> </span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a> result <span class="ot">&lt;-</span> coro<span class="sc">::</span><span class="fu">await</span>(result_promise)</span>
<span id="cb4-9"><a href="#cb4-9" tabindex="-1"></a> <span class="fu">return</span>(result)</span></code></pre></div>
<p>}) ``<code>2. Clone chat object for parallel execution:</code>chat &lt;- chat$clone()`</p>
</div>
<div class="section level3">
<h3 id="id_44-wrap-sync-agents-for-async-mode">4.4 Wrap Sync Agents for Async Mode<a class="anchor" aria-label="anchor" href="#id_44-wrap-sync-agents-for-async-mode"></a></h3>
<p><strong>Steps:</strong> 1. Create <code>async_wrap()</code> helper that wraps synchronous functions in <code><a href="https://coro.r-lib.org/reference/async.html" class="external-link">coro::async()</a></code> 2. Deterministic function agents continue working in async scheduler</p>
<hr></div>
</div>
<div class="section level2">
<h2 id="phase-5-manifest-validation">Phase 5: Manifest Validation<a class="anchor" aria-label="anchor" href="#phase-5-manifest-validation"></a></h2>
<p><strong>Why:</strong> Prevent invalid configurations that cause undefined behavior in async mode.</p>
<div class="section level3">
<h3 id="id_51-critical-state-validation">5.1 Critical State Validation<a class="anchor" aria-label="anchor" href="#id_51-critical-state-validation"></a></h3>
<p><strong>Location:</strong> <code>R/class-policy.R</code> (Manifest validator)</p>
<p><strong>Steps:</strong> 1. Validate that <code>critical = TRUE</code> states have unique priority within their stage 2. Error if critical state shares priority with other states</p>
</div>
<div class="section level3">
<h3 id="id_52-final-state-validation">5.2 Final State Validation<a class="anchor" aria-label="anchor" href="#id_52-final-state-validation"></a></h3>
<p><strong>Steps:</strong> 1. Add similar validation for <code>final = TRUE</code> states 2. Final states must have unique priority (race condition if parallel)</p>
</div>
<div class="section level3">
<h3 id="id_53-dependency-validation">5.3 Dependency Validation<a class="anchor" aria-label="anchor" href="#id_53-dependency-validation"></a></h3>
<p><strong>Steps:</strong> 1. Validate <code>depends_on</code> references exist in manifest 2. Validate dependent state has lower priority than dependency (enforces execution order) 3. Detect circular dependencies</p>
<hr></div>
</div>
<div class="section level2">
<h2 id="phase-6-error-handling--timeouts">Phase 6: Error Handling &amp; Timeouts<a class="anchor" aria-label="anchor" href="#phase-6-error-handling--timeouts"></a></h2>
<div class="section level3">
<h3 id="id_61-add-timeout-property-to-statepolicy">6.1 Add <code>timeout</code> Property to StatePolicy<a class="anchor" aria-label="anchor" href="#id_61-add-timeout-property-to-statepolicy"></a></h3>
<p><strong>Location:</strong> <code>R/class-policy.R</code></p>
<p><strong>Steps:</strong> 1. Add property: <code>timeout = S7::new_property(class = S7::class_integer, default = NA_integer_)</code> 2. Implement in async scheduler using <code><a href="https://rstudio.github.io/promises/reference/promise_all.html" class="external-link">promises::promise_race()</a></code> with timeout promise</p>
</div>
<div class="section level3">
<h3 id="id_62-promise-rejection-handling">6.2 Promise Rejection Handling<a class="anchor" aria-label="anchor" href="#id_62-promise-rejection-handling"></a></h3>
<p><strong>Location:</strong> <code>R/class-scheduler.R</code></p>
<p><strong>Steps:</strong> 1. Wrap parallel executions with error capture 2. Aggregate errors from all parallel states 3. Decide policy: continue on partial failure or abort?</p>
<hr></div>
</div>
<div class="section level2">
<h2 id="open-questions">Open Questions<a class="anchor" aria-label="anchor" href="#open-questions"></a></h2>
<div class="section level3">
<h3 id="q1-on_failure-with-different-priorities">Q1: <code>on_failure</code> with Different Priorities<a class="anchor" aria-label="anchor" href="#q1-on_failure-with-different-priorities"></a></h3>
<p><strong>Current behavior:</strong> <code>on_failure</code> jumps to named recovery state when current state fails.</p>
<p><strong>Async complexity:</strong> If <code>on_failure</code> target has different priority:</p>
<p><strong>Case A: <code>on_failure</code> target has HIGHER priority</strong> - Example: State at priority 50 fails → jumps to state at priority 100 - The priority 100 level has already completed - <strong>Question:</strong> Should we re-execute that priority level? Or inject the failure handler into the current level? - <strong>Consideration:</strong> If we await for the failure handler before proceeding, we break the “all same-priority complete before next level” model - <strong>Possible solution:</strong> Require <code>on_failure</code> targets to have same or lower priority? Or allow higher priority but document the await behavior?</p>
<p><strong>Case B: <code>on_failure</code> target has LOWER priority</strong> - Example: State at priority 100 fails → jumps to state at priority 50 - The priority 50 level hasn’t executed yet - <strong>Behavior:</strong> Natural fit - failure handler will run when its priority level executes - <strong>Question:</strong> Should the failure handler run INSTEAD of the failed state’s normal successor? Or in addition to?</p>
<p><strong>Case C: <code>on_failure</code> target has SAME priority</strong> - Example: State A at priority 100 fails → jumps to state B at priority 100 - <strong>Risk:</strong> If both are in same parallel group, state B might already be running! - <strong>Possible solution:</strong> States with <code>on_failure</code> pointing to same-priority states cannot be in parallel group?</p>
<p><strong>NEEDS CAREFUL DESIGN DECISION - document chosen behavior clearly</strong></p>
</div>
<div class="section level3">
<h3 id="q2-partial-parallel-failure-policy">Q2: Partial Parallel Failure Policy<a class="anchor" aria-label="anchor" href="#q2-partial-parallel-failure-policy"></a></h3>
<p>If 3 of 4 parallel states succeed and 1 fails: - <strong>Option A:</strong> Continue to next priority level (optimistic) - <strong>Option B:</strong> Abort entire stage (pessimistic) - <strong>Option C:</strong> Configurable per-state or per-manifest</p>
<p><strong>Recommendation:</strong> Default to Option A unless failed state is <code>critical</code></p>
</div>
<div class="section level3">
<h3 id="q3-result-ordering">Q3: Result Ordering<a class="anchor" aria-label="anchor" href="#q3-result-ordering"></a></h3>
<p>With parallel execution, result completion order differs from priority order. - Log timestamps will reflect actual completion time - <code>list_attachments()</code> order may not match priority order - <strong>Recommendation:</strong> Accept this as expected async behavior, document it</p>
<hr></div>
</div>
<div class="section level2">
<h2 id="testing-strategy">Testing Strategy<a class="anchor" aria-label="anchor" href="#testing-strategy"></a></h2>
<div class="section level3">
<h3 id="unit-tests">Unit Tests<a class="anchor" aria-label="anchor" href="#unit-tests"></a></h3>
<ul><li>
<code>tests/testthat/test-async-execution.R</code> - Parallel state execution</li>
<li>
<code>tests/testthat/test-explicit-dependencies.R</code> - <code>depends_on</code> resolution</li>
<li>
<code>tests/testthat/test-async-errors.R</code> - Error propagation and timeouts</li>
</ul></div>
<div class="section level3">
<h3 id="integration-tests">Integration Tests<a class="anchor" aria-label="anchor" href="#integration-tests"></a></h3>
<ul><li>Concurrent LLM calls complete faster than sequential</li>
<li>
<code>ExecutionContext</code> isolation prevents cross-talk</li>
<li>File locking prevents index corruption under parallel writes</li>
</ul></div>
<div class="section level3">
<h3 id="stress-tests">Stress Tests<a class="anchor" aria-label="anchor" href="#stress-tests"></a></h3>
<ul><li>100+ parallel log writes without corruption</li>
<li>10+ concurrent Chat agents with separate contexts</li>
</ul><hr></div>
</div>
<div class="section level2">
<h2 id="migration-path">Migration Path<a class="anchor" aria-label="anchor" href="#migration-path"></a></h2>
<div class="section level3">
<h3 id="backward-compatibility">Backward Compatibility<a class="anchor" aria-label="anchor" href="#backward-compatibility"></a></h3>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Sync mode (default - unchanged)</span></span>
<span><span class="va">scheduler</span> <span class="op">&lt;-</span> <span class="va"><a href="reference/Scheduler.html">Scheduler</a></span><span class="op">$</span><span class="fu">new</span><span class="op">(</span><span class="va">manifest</span>, <span class="va">agents</span><span class="op">)</span></span>
<span><span class="va">scheduler</span><span class="op">$</span><span class="fu">start</span><span class="op">(</span><span class="op">)</span>  <span class="co"># Blocking, sequential</span></span>
<span></span>
<span><span class="co"># Async mode (opt-in)</span></span>
<span><span class="va">scheduler</span> <span class="op">&lt;-</span> <span class="va"><a href="reference/Scheduler.html">Scheduler</a></span><span class="op">$</span><span class="fu">new</span><span class="op">(</span><span class="va">manifest</span>, <span class="va">agents</span>, async <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="fu">coro</span><span class="fu">::</span><span class="fu">async_run</span><span class="op">(</span><span class="va">scheduler</span><span class="op">$</span><span class="fu">start</span><span class="op">(</span><span class="op">)</span><span class="op">)</span>  <span class="co"># Non-blocking, parallel</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="deprecation-schedule">Deprecation Schedule<a class="anchor" aria-label="anchor" href="#deprecation-schedule"></a></h3>
<ol style="list-style-type: decimal"><li>
<strong>v1.x:</strong> <code>accessibility = "all"</code> / <code>"logs"</code> continue working, emit deprecation warning in async mode</li>
<li>
<strong>v2.x:</strong> Require <code>accessibility = "explicit"</code> with <code>depends_on</code> for agents that read previous results in async mode</li>
</ol></div>
</div>
</div>

  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p>Developed by Dipterix Wang.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.2.0.</p>
</div>

    </footer></div>





  </body></html>


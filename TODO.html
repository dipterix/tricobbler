<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en-US"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>TriCobbler Async Architecture TODO • tricobbler</title><script src="deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet"><link href="deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet"><script src="deps/headroom-0.11.0/headroom.min.js"></script><script src="deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="deps/search-1.0.0/fuse.min.js"></script><script src="deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="pkgdown.js"></script><meta property="og:title" content="TriCobbler Async Architecture TODO"></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="index.html">tricobbler</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.0.0.9000</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="nav-item"><a class="nav-link" href="reference/index.html">Reference</a></li>
      </ul><ul class="navbar-nav"><li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="search.json"></form></li>
      </ul></div>


  </div>
</nav><div class="container template-title-body">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>TriCobbler Async Architecture TODO</h1>

    </div>

<div id="tricobbler-async-architecture-todo" class="section level1">

<p>This document outlines the implementation plan for async/parallel execution support in tricobbler.</p>
<div class="section level2">
<h2 id="overview">Overview<a class="anchor" aria-label="anchor" href="#overview"></a></h2>
<p><strong>Goal:</strong> Enable concurrent agent execution using R promises, allowing multiple LLM calls to run simultaneously without blocking. Each agent should return a <code>promise</code> object</p>
<p><strong>Architecture Decision:</strong> Use <code>coro</code> + <code>promises</code> (not <code>future</code>) because: - LLM agents are I/O-bound (waiting for API responses), not CPU-bound - Single-process async avoids serialization overhead of multi-process approaches - <code><a href="https://ellmer.tidyverse.org/reference/Chat.html" class="external-link">ellmer::Chat</a></code> supports <code>chat$chat_async()</code>, <code>chat$stream_async()</code>, <code>chat$chat_structured_async()</code> returning promises - <code>chat$clone()</code> is supported for parallel Chat agent isolation - Simpler thread-safety model (single event loop vs file locking)</p>
<hr></div>
<div class="section level2">
<h2 id="phase-1-foundation---explicit-dependencies-done">Phase 1: Foundation - Explicit Dependencies [Done]<a class="anchor" aria-label="anchor" href="#phase-1-foundation---explicit-dependencies-done"></a></h2>
<p><strong>Why:</strong> Current <code>last_results(1)</code> returns chronologically last result. With parallel execution, result order is non-deterministic. Agents must explicitly declare which states they depend on.</p>
<div class="section level3">
<h3 id="id_11-add-depends_on-property-to-statepolicy">1.1 Add <code>depends_on</code> Property to StatePolicy<a class="anchor" aria-label="anchor" href="#id_11-add-depends_on-property-to-statepolicy"></a></h3>
<p><strong>Location:</strong> <code>R/class-policy.R</code></p>
<p><strong>Steps:</strong> 1. Add new S7 property to <code>StatePolicy</code>: <code>r    depends_on = S7::new_property(      class = StateDeps,  # Implemented as separate S7 class      default = StateDeps()    )</code> 2. Each dependency entry should be a named list element (key = parameter name): - <code>state</code>: Name of the state this depends on (character) - <code>field</code>: What to extract - <code>"result"</code> or <code>"description"</code> (character) - <code>stage</code>: (Optional) Stage name if depending on earlier stage 3. Add validator to <code>StateDeps</code> to ensure entries have required fields (format) 4. Add validator to property <code>states</code> in <code>Manifest</code> to ensure the dependency entries are valid (logic) 5. Update <code><a href="reference/manifest-file.html">manifest_write()</a></code> and <code><a href="reference/manifest-file.html">manifest_read()</a></code> for serialization</p>
<p><strong>Example manifest:</strong></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">states</span><span class="kw">:</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="at">  </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> aggregator</span></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="at">    </span><span class="fu">stage</span><span class="kw">:</span><span class="at"> executing</span></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="at">    </span><span class="fu">priority</span><span class="kw">:</span><span class="at"> </span><span class="dv">50</span></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="at">    </span><span class="fu">agent_id</span><span class="kw">:</span><span class="at"> aggregator_agent</span></span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="at">    </span><span class="fu">accessibility</span><span class="kw">:</span><span class="at"> explicit</span></span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a><span class="at">    </span><span class="fu">depends_on</span><span class="kw">:</span></span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a><span class="at">      </span><span class="fu">validation_result</span><span class="kw">:</span></span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a><span class="at">        </span><span class="fu">state</span><span class="kw">:</span><span class="at"> validator</span></span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a><span class="at">        </span><span class="fu">field</span><span class="kw">:</span><span class="at"> result</span></span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a><span class="at">      </span><span class="fu">parsed_data</span><span class="kw">:</span></span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a><span class="at">        </span><span class="fu">state</span><span class="kw">:</span><span class="at"> parser</span></span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a><span class="at">        </span><span class="fu">field</span><span class="kw">:</span><span class="at"> result</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="id_12-add-accessibility--explicit-level">1.2 Add <code>accessibility = "explicit"</code> Level<a class="anchor" aria-label="anchor" href="#id_12-add-accessibility--explicit-level"></a></h3>
<p><strong>Location:</strong> <code>R/class-policy.R</code>, <code>R/class-baseagent.R</code></p>
<p><strong>Steps:</strong> 1. Update <code>accessibility</code> property validator to accept <code>"explicit"</code> value 2. Modify <code><a href="reference/as_agent.html">as_agent()</a></code> wrapper to handle <code>"explicit"</code> accessibility: - Build inputs from <code>depends_on</code> mapping instead of <code>last_results()</code> (for deterministic agents such as functions or MCP tools) - For AI agents, include the <code>depends_on</code> as its chat context (into user prompts, see item 3) - Use new <code>get_attachment_by_state()</code> method (see 1.3) 3. Keep <code>"all"</code>, <code>"logs"</code>, <code>"none"</code> working: - “none”: agent have no access to logs nor attachment; under this situation, <code>depends_on</code> only indicates that this agent should await for the dependents to finish, but cannot access their contents - “logs”: agent have access to logs and attachment list but not contents; under this situation, <code>depends_on</code> only indicates that this agent should await for the dependents to finish, but cannot access their contents - “explicit”: agent have access to logs, attachment list, but only with the attachments from <code>depends_on</code> list. The MCP tool to read attachments will not be provided. However, all the <code>depends_on</code> descriptions will be included in the user prompt - “all”: agent will be provided tools to access all logs and attachments, the user prompt also includes <code>depends_on</code> descriptions</p>
</div>
<div class="section level3">
<h3 id="id_13-add-get_attachment_by_state-to-context">1.3 Add <code>get_attachment_by_state()</code> to Context<a class="anchor" aria-label="anchor" href="#id_13-add-get_attachment_by_state-to-context"></a></h3>
<p><strong>Location:</strong> <code>R/class-context.R</code></p>
<p><strong>Steps:</strong> 1. Add new public method: <code>r    get_attachment_by_state = function(state, stage) {      # Find attachment matching state and stage      # Return most recent match if multiple exist (retries)    }</code> 2. Use <code>private$.results</code> index to locate attachment by state name 3. Load and return the attachment object</p>
<hr></div>
</div>
<div class="section level2">
<h2 id="phase-2-globals-isolation-done">Phase 2: Globals Isolation [Done]<a class="anchor" aria-label="anchor" href="#phase-2-globals-isolation-done"></a></h2>
<p><strong>Why:</strong> Current globals (<code>active_context</code>, <code>active_agent</code>, <code>active_policy</code>) in <code>R/aaa.R</code> are shared across all agents. With parallel execution, concurrent agents overwrite each other’s globals, causing MCP tools to receive wrong context.</p>
<div class="section level3">
<h3 id="id_21-create-agentruntime-class">2.1 Create AgentRuntime Class<a class="anchor" aria-label="anchor" href="#id_21-create-agentruntime-class"></a></h3>
<p><strong>Location:</strong> <code>R/class-runtime.R</code></p>
<p><strong>Implementation:</strong> 1. Created <code>AgentRuntime</code> R6 class with per-execution state: <code>r    AgentRuntime &lt;- R6::R6Class(      private = list(        .agent = NULL,        # Current Agent (who)        .context = NULL,      # AgentContext (where)        .policy = NULL,       # StatePolicy (what)        .execution_id = NULL  # Unique ID for this execution      ),      active = list(        agent = function() { private$.agent },        context = function() { private$.context },        policy = function() { private$.policy },        execution_id = function() { private$.execution_id }      ),      public = list(        logger = function(...) { ... },  # Convenience method        run = function(attempt) { ... },       # Sync execution        run_async = function(attempt) { ... }  # Async execution      )    )</code> 2. Runtime is instantiated per-execution in Scheduler and passed to agents 3. Encapsulates execution logic with <code>run()</code> and <code>run_async()</code> methods using <code><a href="https://coro.r-lib.org/reference/async.html" class="external-link">coro::async</a></code>/<code>await</code></p>
</div>
<div class="section level3">
<h3 id="id_22-update-mcp-tools-for-explicit-runtime">2.2 Update MCP Tools for Explicit Runtime<a class="anchor" aria-label="anchor" href="#id_22-update-mcp-tools-for-explicit-runtime"></a></h3>
<p><strong>Location:</strong> <code>R/mcp-tooldef-config.R</code>, <code>R/mcp-tooldef-context.R</code>, <code>R/mcp-tools.R</code></p>
<p><strong>Implementation:</strong> 1. Added <code>.runtime</code> parameter to all MCP tools: <code>r    mcp_tool_context_logs_tail &lt;- function(max_lines, skip_lines, .runtime = NULL) {      ctx &lt;- if (!is.null(.runtime)) .runtime$context else NULL      # ...    }</code> 2. <code><a href="reference/mcptool_instantiate.html">mcptool_instantiate()</a></code> detects <code>.runtime</code> parameter via <code><a href="https://rdrr.io/r/base/formals.html" class="external-link">formals()</a></code> inspection 3. Runtime is injected via closure capture at tool instantiation time: <code>r    mcptool_instantiate &lt;- function(tool, ..., runtime = NULL) {      has_runtime_param &lt;- ".runtime" %in% names(formals(impl))      wrapper_fun &lt;- function() {        if (has_runtime_param &amp;&amp; !is.null(runtime)) {          call[[".runtime"]] &lt;- runtime        }        # ...      }    }</code> 4. Removed globals infrastructure (<code>set_globals</code>, <code>get_globals</code>, <code>get_active_context</code>)</p>
</div>
<div class="section level3">
<h3 id="id_23-update-agent-function-signature">2.3 Update Agent Function Signature<a class="anchor" aria-label="anchor" href="#id_23-update-agent-function-signature"></a></h3>
<p><strong>Location:</strong> <code>R/class-baseagent.R</code></p>
<p><strong>Implementation:</strong> 1. Agent functions now require <code>runtime</code> as the first parameter: <code>r    function(runtime, ...) {      # runtime$agent - the Agent object itself      # runtime$policy - the StatePolicy being executed      # runtime$context - the Context for logging      # runtime$logger() - shorthand for logging    }</code> 2. Validator enforces <code>runtime</code> as first argument name 3. Scheduler creates runtime and calls <code>runtime$run()</code>, records results via <code><a href="https://rdrr.io/r/base/do.call.html" class="external-link">do.call()</a></code></p>
<hr></div>
</div>
<div class="section level2">
<h2 id="phase-3-per-runtime-logging--atomic-attachments-done">Phase 3: Per-Runtime Logging &amp; Atomic Attachments [Done]<a class="anchor" aria-label="anchor" href="#phase-3-per-runtime-logging--atomic-attachments-done"></a></h2>
<p><strong>Why:</strong> Each <code>AgentRuntime</code> owns its execution lifecycle completely—one runtime = one attempt = one attachment. Per-runtime log files enable crash inspection and clean separation of concerns without file locking (unnecessary since R promises/coro are single-threaded).</p>
<p><strong>Key insight:</strong> One <code>AgentRuntime</code> = one execution attempt = one attachment. The <code>attachment_id</code> (format <code>[stage][state][agent_id]_YYMMDDTHHMMSS_{attempt}</code>) is the primary key across log files, <code>.rds</code> attachments, and the SQLite index.</p>
<div class="section level3">
<h3 id="id_31-move-attempt-to-agentruntime-initializer-done">3.1 Move <code>attempt</code> to AgentRuntime Initializer [Done]<a class="anchor" aria-label="anchor" href="#id_31-move-attempt-to-agentruntime-initializer-done"></a></h3>
<p><strong>Location:</strong> <code>R/class-runtime.R</code></p>
<p><strong>Implementation:</strong> 1. <code>AgentRuntime$new(agent, context, policy, attempt = 0L)</code> — attempt is validated and stored at construction 2. <code>attachment_id</code> is generated immediately in the constructor: <code>r    private$.attachment_id &lt;- sprintf(      "[%s][%s][%s]_%s_%d",      policy@stage, policy@name, agent@id,      format(now, "%y%m%dT%H%M%S"), attempt    )</code> 3. Runtime registers itself in <code>AttachmentIndex</code> with status <code>"init"</code> at construction 4. <code>run()</code> and <code>run_async()</code> take no arguments — attempt is already known 5. Scheduler creates a fresh <code>AgentRuntime</code> per retry attempt, passing the cumulative retry count</p>
</div>
<div class="section level3">
<h3 id="id_32-per-runtime-log-file-done">3.2 Per-Runtime Log File [Done]<a class="anchor" aria-label="anchor" href="#id_32-per-runtime-log-file-done"></a></h3>
<p><strong>Location:</strong> <code>R/class-runtime.R</code></p>
<p><strong>Implementation:</strong> 1. <code>$logger(...)</code> writes to <code>{attachment_path}/{attachment_id}.log</code> via <code>log_to_file()</code>, and optionally mirrors to the main context log when running in the main process (<code><a href="https://rdrr.io/r/base/Sys.getpid.html" class="external-link">Sys.getpid()</a></code> check) 2. <code>$logger()</code> supports <code>level</code>, <code>verbose</code>, <code>public</code>, and <code>role</code> parameters — reuses the shared <code>log_to_file()</code> helper from <code>R/helper-logger.R</code> 3. No separate <code>$get_logs()</code> on runtime — context provides <code>$get_runtime_log(attachment_id)</code> instead</p>
</div>
<div class="section level3">
<h3 id="id_33-timing-capture--result-recording-done">3.3 Timing Capture &amp; Result Recording [Done]<a class="anchor" aria-label="anchor" href="#id_33-timing-capture--result-recording-done"></a></h3>
<p><strong>Location:</strong> <code>R/class-runtime.R</code></p>
<p><strong>Implementation:</strong> 1. <code>private$.create_run_impl()</code> captures <code>time_started &lt;- Sys.time()</code> at execution start and passes <code>started</code> and <code>duration</code> to <code>.record_result()</code> 2. <code>private$.record_result(result, succeed, ...)</code> handles all result finalization: - Calls <code>agent@describe(result)</code> for human-readable description - Saves <code>.rds</code> attachment to <code>{attachment_path}/{attachment_id}.rds</code> - Logs result summary: <code>Status=finished</code> or <code>Status=errored</code> - Calls <code>context$record_attachment(runtime, succeed)</code> to update index 3. Index status transitions: <code>init</code> → <code>running</code> (at execution start) → <code>finished</code>/<code>errored</code> (at result recording)</p>
</div>
<div class="section level3">
<h3 id="id_34-sqlite-backed-attachmentindex-done">3.4 SQLite-Backed AttachmentIndex [Done]<a class="anchor" aria-label="anchor" href="#id_34-sqlite-backed-attachmentindex-done"></a></h3>
<p><strong>Location:</strong> <code>R/class-attachment-index.R</code> (new file)</p>
<p><strong>Implementation:</strong> <code>AttachmentIndex</code> R6 class backed by RSQLite, replacing the previous text-based <code>.results</code> data.frame in <code>AgentContext</code>.</p>
<ol style="list-style-type: decimal"><li>
<p><strong>Schema:</strong></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode sql"><code class="sourceCode sql"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="kw">CREATE</span> <span class="kw">TABLE</span> attachment_index (</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>  attachment_id TEXT <span class="kw">PRIMARY</span> <span class="kw">KEY</span>,</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>  stage         TEXT <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a>  state         TEXT <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a>  agent_id      TEXT <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a>  attempt       <span class="dt">INTEGER</span> <span class="kw">NOT</span> <span class="kw">NULL</span> <span class="kw">DEFAULT</span> <span class="dv">0</span>,</span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a>  status        TEXT <span class="kw">NOT</span> <span class="kw">NULL</span> <span class="kw">DEFAULT</span> <span class="st">'init'</span>,</span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a>  succeed       <span class="dt">INTEGER</span>,</span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a>  created_at    <span class="dt">REAL</span> <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a>  updated_at    <span class="dt">REAL</span> <span class="kw">NOT</span> <span class="kw">NULL</span></span>
<span id="cb2-11"><a href="#cb2-11" tabindex="-1"></a>)</span></code></pre></div>
<p>Indexes on <code>(state, stage)</code> and <code>(status)</code> for common queries.</p>
</li>
<li><p><strong>Connection lifecycle:</strong> Open/close per operation via <code>private$.with_db(callback)</code> — negligible overhead for ~3-15 writes per scheduler run, and safe against connection leaks.</p></li>
<li><p><strong>Backend abstraction:</strong> All SQLite calls are isolated in <code>$.with_db()</code> and <code>$.init_db()</code>. To swap to duckdb or another backend, only these two private methods need modification.</p></li>
<li>
<p><strong>Public API:</strong></p>
<ul><li>
<code>$register(attachment_id, stage, state, agent_id, attempt)</code> — INSERT OR REPLACE with status <code>"init"</code>
</li>
<li>
<code>$update_status(attachment_id, status)</code> — set status to any of <code>init/running/finished/errored/skipped</code>
</li>
<li>
<code>$mark_finished(attachment_id, succeed)</code> — convenience: sets status + succeed flag</li>
<li>
<code>$get(attachment_id)</code> — single-row lookup</li>
<li>
<code>$list(status = NULL)</code> — all entries, most recent first, optional status filter</li>
<li>
<code>$query(state, stage, status)</code> — filter by state/stage/status</li>
<li>
<code>$list_incomplete(timeout_secs = NULL)</code> — entries with status <code>init</code> or <code>running</code>, optionally past a timeout</li>
<li>
<code>$exists(attachment_id)</code> — fast existence check</li>
<li>
<code>$get_db_path()</code> — returns the SQLite file path</li>
</ul></li>
<li><p><strong>Status lifecycle:</strong> <code>init</code> → <code>running</code> → <code>finished</code> | <code>errored</code> (and <code>skipped</code> reserved for future use)</p></li>
</ol></div>
<div class="section level3">
<h3 id="id_35-simplified-agentcontext-done">3.5 Simplified AgentContext [Done]<a class="anchor" aria-label="anchor" href="#id_35-simplified-agentcontext-done"></a></h3>
<p><strong>Location:</strong> <code>R/class-context.R</code></p>
<p><strong>Implementation:</strong> 1. <code>private$.results</code> (data.frame) replaced with <code>private$.index</code> (AttachmentIndex) 2. <code>init_resources()</code> creates <code>AttachmentIndex$new(db_path)</code> at <code>{attachment_path}/index.sqlite</code> 3. <code>$index</code> active binding exposes the index (read-only) 4. <code>record_attachment(runtime, succeed)</code> delegates to <code>index$mark_finished()</code> — logs <code>status=finished</code> or <code>status=errored</code> 5. <code>last_results()</code>, <code>get_attachment()</code>, <code>get_attachment_by_state()</code>, <code>list_attachments()</code> all query the index 6. New <code>$list_incomplete(timeout_secs)</code> — delegates to <code>index$list_incomplete()</code> 7. New <code>$get_runtime_log(attachment_id)</code> — reads <code>{attachment_path}/{attachment_id}.log</code></p>
</div>
<div class="section level3">
<h3 id="id_36-scheduler-integration-done">3.6 Scheduler Integration [Done]<a class="anchor" aria-label="anchor" href="#id_36-scheduler-integration-done"></a></h3>
<p><strong>Location:</strong> <code>R/class-scheduler.R</code></p>
<p><strong>Implementation:</strong> 1. Creates fresh <code>AgentRuntime$new(agent, context, policy, attempt = init_retry_count)</code> per attempt 2. Calls <code>runtime$run()</code> which internally handles the full lifecycle (init → running → record result → update index) 3. Retry logic remains in scheduler (<code>retry_map</code> tracks cumulative failure count per state) 4. Fixed bare <code>context</code> → <code>self$context</code> reference bug</p>
</div>
<div class="section level3">
<h3 id="id_37-bug-fixes-applied">3.7 Bug Fixes Applied<a class="anchor" aria-label="anchor" href="#id_37-bug-fixes-applied"></a></h3>
<ol style="list-style-type: decimal"><li>
<strong>Column name mismatch:</strong> <code>init_resources()</code> used <code>attachment_id</code> but <code>record_attachment()</code> used <code>filename</code> — fixed by SQLite schema where column names are defined once</li>
<li>
<strong>MCP fallback mismatch:</strong> Empty fallback data.frame used <code>current_attempt</code> but actual data used <code>attempt</code> — fixed by consistent schema</li>
<li>
<strong>Test references:</strong> All <code>$filename</code> references in tests updated to <code>$attachment_id</code>
</li>
<li>
<strong>RSQLite added to DESCRIPTION Imports</strong>, <code>@importFrom RSQLite SQLite</code> added to namespace</li>
</ol></div>
<div class="section level3">
<h3 id="dependencies-added">Dependencies Added<a class="anchor" aria-label="anchor" href="#dependencies-added"></a></h3>
<ul><li>
<code>RSQLite (&gt;= 2.3.0)</code> in DESCRIPTION Imports</li>
<li>
<code>R/class-attachment-index.R</code> added to Collate (before <code>class-context.R</code>)</li>
</ul><hr></div>
</div>
<div class="section level2">
<h2 id="phase-4-async-scheduler-done">Phase 4: Async Scheduler [Done]<a class="anchor" aria-label="anchor" href="#phase-4-async-scheduler-done"></a></h2>
<p><strong>Why:</strong> Enable concurrent execution of independent states. All agent-level async primitives are already in place (<code>AgentRuntime$run_async</code>, <code>chat_async</code>/<code>chat_structured_async</code> dispatch, <code>StateDeps</code>, <code>AttachmentIndex</code>). This phase adds the scheduler orchestration layer.</p>
<p><strong>Architecture:</strong> Queue + Waiting Pool (replaces the original rigid priority-group model). States enter a ready-queue when their <code>depends_on</code> are satisfied, get dispatched into a bounded waiting pool, and the scheduler drains the pool as promises resolve — feeding newly-unblocked states into the queue without waiting for an entire priority tier to finish.</p>
<p><strong>Key insight:</strong> R’s <code>coro</code>/<code>promises</code> async is single-threaded cooperative multitasking, not true parallelism. All R code runs on one thread; concurrency only happens during I/O waits (e.g., waiting for LLM API responses). This means: - No race conditions on R-side data structures (no mutexes needed) - SQLite open/close-per-operation is safe without WAL mode - The event loop yields control only at <code>await</code> points - <code>chat$clone(deep = TRUE)</code> is still needed because multiple agents sharing the same <code>Chat</code> would corrupt conversation state when interleaved at <code>await</code> boundaries</p>
<div class="section level3">
<h3 id="id_41-direct-function-call-lifecycle-event-system-done">4.1 Direct Function-Call Lifecycle Event System [Done]<a class="anchor" aria-label="anchor" href="#id_41-direct-function-call-lifecycle-event-system-done"></a></h3>
<p><strong>Location:</strong> <code>R/class-event-dispatcher.R</code>, <code>R/helper-conditions.R</code></p>
<p><strong>Why:</strong> The scheduler needs to communicate lifecycle events (suspend, state completed, stage completed, dispatch) to callers. Rather than requiring users to wrap <code>scheduler$start()</code> in <code><a href="https://rdrr.io/r/base/conditions.html" class="external-link">withCallingHandlers()</a></code>, the Scheduler owns an internal <code>EventDispatcher</code> that manages a listener registry. Users call <code>scheduler$on("suspend", handler)</code> to register listeners.</p>
<p><strong>Design decision:</strong> The original plan specified a condition-based approach (<code>signalCondition</code>/<code>withCallingHandlers</code>/<code>withRestarts</code>/<code>$wrap()</code>). This was abandoned because <code><a href="https://coro.r-lib.org/reference/async.html" class="external-link">coro::async</a></code> does <strong>not</strong> support <code><a href="https://rdrr.io/r/base/conditions.html" class="external-link">withCallingHandlers()</a></code> inside coroutine bodies — conditions raised after an <code>await</code> point escape the handler frame. Instead, the dispatcher uses <strong>direct function-call dispatch</strong>: <code>$emit(event)</code> iterates a snapshot of the handler list and calls each <code>handler(event)</code> directly. This is compatible with <code><a href="https://coro.r-lib.org/reference/async.html" class="external-link">coro::async</a></code> and avoids the coroutine limitation entirely.</p>
<p><strong>Architecture:</strong> - <code>EventDispatcher</code> (internal R6 class) owns a per-type ordered handler list and provides <code>$on()</code>, <code>$off()</code>, <code>$emit()</code>, <code>$has()</code>, <code>$clear()</code> methods - The Scheduler composes an <code>EventDispatcher</code> instance (has-a, not is-a) and delegates <code>$on()</code> / <code>$off()</code> as public methods - <code>$emit(event)</code> returns the <strong>first non-NULL</strong> handler return value (first-wins semantics) — used by <code>suspend</code> to capture the chosen action string from a listener - No <code>$wrap()</code> method — no conditions, no restarts, no <code>withCallingHandlers</code>/<code>withRestarts</code></p>
<p><strong>Implementation:</strong></p>
<ol style="list-style-type: decimal"><li>
<p><strong>Event constructors</strong> in <code>R/helper-conditions.R</code>:</p>
<ul><li>
<code>tricobbler_event(type, message, ...)</code> — creates a plain list with <code>class = c("tricobbler_&lt;type&gt;", "tricobbler_lifecycle")</code> and all fields spread flat. These are <strong>not</strong> R conditions; they are plain list event objects passed to <code>$emit()</code>.</li>
</ul></li>
<li>
<p><strong>Lifecycle event types</strong> (emitted by the Scheduler via <code>dispatch_event()</code>):</p>
<table class="table"><colgroup><col width="25%"><col width="25%"><col width="25%"><col width="25%"></colgroup><thead><tr class="header"><th>Event type</th>
<th>When emitted</th>
<th>Key fields</th>
<th>Semantics</th>
</tr></thead><tbody><tr class="odd"><td><code>suspend</code></td>
<td>Critical state failed, retries exhausted</td>
<td><code>state_name, stage, error</code></td>
<td>First-wins: handler return value becomes the suspend action</td>
</tr><tr class="even"><td><code>runtime.resolved</code></td>
<td>A runtime promise resolved successfully</td>
<td><code>runtime, result</code></td>
<td>Informational</td>
</tr><tr class="odd"><td><code>runtime.exhausted</code></td>
<td>A state exhausted all retries</td>
<td><code>runtime, result</code></td>
<td>Informational</td>
</tr><tr class="even"><td><code>runtime.errored</code></td>
<td>A state failed but will retry</td>
<td><code>runtime, result</code></td>
<td>Informational</td>
</tr><tr class="odd"><td><code>runtime.redirect</code></td>
<td>
<code>on_failure</code> redirect triggered</td>
<td><code>runtime, result, target</code></td>
<td>Informational</td>
</tr><tr class="even"><td><code>runtime.dispatch</code></td>
<td>A state is about to be dispatched</td>
<td><code>state_name, stage, attempt</code></td>
<td>Informational</td>
</tr><tr class="odd"><td><code>runtime.skipped</code></td>
<td>A state was skipped (depends on skipped/failed)</td>
<td><code>state_name, stage</code></td>
<td>Informational</td>
</tr><tr class="even"><td><code>runtime.final</code></td>
<td>A <code>final = TRUE</code> state completed; draining</td>
<td><code>state_name</code></td>
<td>Informational</td>
</tr><tr class="odd"><td><code>stage.completed</code></td>
<td>All states in a stage finished</td>
<td><code>stage</code></td>
<td>Informational</td>
</tr><tr class="even"><td><code>init_resources</code></td>
<td>Resources being initialized</td>
<td>—</td>
<td>Informational</td>
</tr><tr class="odd"><td>
<code>init_stage.begin</code> / <code>init_stage.end</code>
</td>
<td>Stage initialization</td>
<td><code>stage</code></td>
<td>Informational</td>
</tr><tr class="even"><td>
<code>enqueue_runtime.begin</code> / <code>enqueue_runtime.end</code> / <code>enqueue_runtime.changed</code>
</td>
<td>Queue cycle events</td>
<td>—</td>
<td>Informational</td>
</tr></tbody></table></li>
<li>
<p><strong>EventDispatcher R6 class</strong> in <code>R/class-event-dispatcher.R</code>:</p>
<ul><li>Uses <code><a href="https://r-lib.github.io/fastmap/reference/fastmap.html" class="external-link">fastmap::fastmap()</a></code> for the top-level type registry and reverse-lookup map</li>
<li>Per-type handlers stored in a plain list to guarantee deterministic execution order</li>
<li>
<code>digest::digest(list(handler, type))</code> auto-generates deterministic IDs, preventing duplicate registration</li>
<li>User-supplied <code>id</code> enables explicit replacement (upsert semantics)</li>
<li>
<code>$on(type, handler, id, after)</code> — <code>after = TRUE</code> appends (default), <code>after = FALSE</code> prepends</li>
<li>
<code>$off(id, types)</code> — removes by ID; reverse-lookup avoids needing the type</li>
<li>
<code>$has(type, id)</code> — checks whether a listener is registered</li>
<li>
<code>$clear(type)</code> — clears one or all types; also called from <code>finalize()</code>
</li>
</ul></li>
<li>
<p><strong>Composed into Scheduler:</strong></p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Delegate listener registration</span></span>
<span><span class="va">scheduler</span><span class="op">$</span><span class="fu">on</span><span class="op">(</span><span class="st">"runtime.resolved"</span>, <span class="kw">function</span><span class="op">(</span><span class="va">event</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/cat.html" class="external-link">cat</a></span><span class="op">(</span><span class="st">"Done:"</span>, <span class="va">event</span><span class="op">$</span><span class="va">state_name</span>, <span class="st">"\n"</span><span class="op">)</span></span>
<span><span class="op">}</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Auto-skip on suspend (CI/tests):</span></span>
<span><span class="va">scheduler</span><span class="op">$</span><span class="fu">on</span><span class="op">(</span><span class="st">"suspend"</span>, <span class="kw">function</span><span class="op">(</span><span class="va">event</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="st">"skip"</span>  <span class="co"># return value is captured as the action</span></span>
<span><span class="op">}</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Custom suspend logic:</span></span>
<span><span class="va">scheduler</span><span class="op">$</span><span class="fu">on</span><span class="op">(</span><span class="st">"suspend"</span>, <span class="kw">function</span><span class="op">(</span><span class="va">event</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="kw">if</span> <span class="op">(</span><span class="va">event</span><span class="op">$</span><span class="va">state_name</span> <span class="op">==</span> <span class="st">"non_essential"</span><span class="op">)</span> <span class="st">"skip"</span> <span class="kw">else</span> <span class="st">"abort"</span></span>
<span><span class="op">}</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Replace a handler by supplying the same id:</span></span>
<span><span class="va">scheduler</span><span class="op">$</span><span class="fu">on</span><span class="op">(</span><span class="st">"suspend"</span>, <span class="va">my_new_handler</span>, id <span class="op">=</span> <span class="st">"my_suspend"</span><span class="op">)</span></span></code></pre></div>
</li>
</ol><p><strong>Why direct-call over condition-based:</strong> - Compatible with <code><a href="https://coro.r-lib.org/reference/async.html" class="external-link">coro::async</a></code> (conditions are not preserved across <code>await</code> points) - Simpler mental model — <code>scheduler$on("event", fn)</code> with return-value semantics - Registration persists across multiple <code><a href="https://rdrr.io/r/stats/start.html" class="external-link">start()</a></code> calls - Multiple listeners for the same event compose naturally - No need to understand R’s condition/restart system</p>
<p><strong>Dependencies:</strong> <code>coro</code>, <code>promises</code>, <code>fastmap</code>, and <code>digest</code> are already in Imports. No new dependencies needed.</p>
</div>
<div class="section level3">
<h3 id="id_42-suspend-with-error-propagation-and-action-dispatch-done">4.2 <code>suspend()</code> with Error Propagation and Action Dispatch [Done]<a class="anchor" aria-label="anchor" href="#id_42-suspend-with-error-propagation-and-action-dispatch-done"></a></h3>
<p><strong>Location:</strong> <code>R/class-scheduler.R</code></p>
<p><strong>Implementation:</strong> 1. <strong>Error propagation:</strong> <code>execute_runtime()</code>’s <code>onFulfilled</code> callback checks <code>result$succeed</code>. When a critical state exhausts retries, the error from the result is passed directly to <code>self$suspend(error = result$error, ...)</code>. <code>private$.last_error</code> is set inline. 2. <strong><code>suspend()</code> implementation</strong> (<code>Scheduler$suspend(error, state_name, stage, runtime_summary)</code>): - Sets <code>self$suspended = TRUE</code> - Captures context in <code>self$suspend_info</code> (state_name, stage, error, timestamp) for inspection - Logs the error with full traceback via <code>utils::capture.output(traceback(error))</code> - Emits <code>"suspend"</code> event via <code>self$dispatch_event()</code> — the return value (first non-NULL handler return) is captured as the action string - If no listener returns an action, falls through to interactive <code><a href="https://rdrr.io/r/utils/menu.html" class="external-link">utils::menu()</a></code> prompt or <code>"abort"</code> in non-interactive mode - Executes the chosen action inline via <code>switch(action, ...)</code>: - <code>"resume"</code>: clears suspended state, re-adds state to <code>runtime_map</code> with <code>attempt = 0</code>, calls <code>advance()</code> - <code>"skip"</code>: clears suspended state, marks state as <code>"skipped"</code> in <code>completed_map</code>, calls <code>private$skip_dependents()</code> to transitively skip downstream dependents, calls <code>advance()</code> - <code>"restart_stage"</code>: clears suspended state, calls <code>self$start_stage(stage)</code> to reset all per-stage structures, re-snapshots <code>.stage_flag</code>, calls <code>advance()</code> - <code>"abort"</code>: clears suspended state, rejects the stage promise via <code>private$.stage_reject()</code> 3. <strong><code>suspend_info</code> field:</strong> Public field set during suspension, cleared on resume/skip/restart/abort. Contains <code>state_name</code>, <code>stage</code>, <code>error</code>, <code>timestamp</code> for external inspection.</p>
</div>
<div class="section level3">
<h3 id="id_43-max_concurrency-and-async-start-done">4.3 <code>max_concurrency</code> and Async <code>start()</code> [Done]<a class="anchor" aria-label="anchor" href="#id_43-max_concurrency-and-async-start-done"></a></h3>
<p><strong>Location:</strong> <code>R/class-scheduler.R</code></p>
<p><strong>Implementation:</strong> 1. <code>max_concurrency</code> field (integer, default <code>100L</code>) — max simultaneous promises in the waiting pool 2. <code><a href="https://rdrr.io/r/stats/start.html" class="external-link">start()</a></code> is itself async — it uses <code><a href="https://coro.r-lib.org/reference/async.html" class="external-link">coro::async</a></code> internally to loop over stages, calling <code>await(self$run_stage(stage))</code> for each. It returns a promise (via <code>impl()$then(...)</code>) that resolves when all stages complete. 3. <strong>No separate <code>start_async()</code></strong> — the original plan to have both <code><a href="https://rdrr.io/r/stats/start.html" class="external-link">start()</a></code> (sync) and <code>start_async()</code> was abandoned. <code><a href="https://rdrr.io/r/stats/start.html" class="external-link">start()</a></code> is the single entry point and is inherently async. Callers block by draining the event loop (e.g., <code><a href="https://later.r-lib.org/reference/run_now.html" class="external-link">later::run_now()</a></code>) or <code>await</code> inside a <code><a href="https://coro.r-lib.org/reference/async.html" class="external-link">coro::async</a></code> context. 4. Stages are always executed sequentially; <code>run_stage()</code> runs all states within a stage concurrently (via queue + pool), returns a promise that resolves when the stage finishes.</p>
</div>
<div class="section level3">
<h3 id="id_44-queue--waiting-pool-dispatch-done">4.4 Queue + Waiting Pool Dispatch [Done]<a class="anchor" aria-label="anchor" href="#id_44-queue--waiting-pool-dispatch-done"></a></h3>
<p><strong>Location:</strong> <code>R/class-scheduler.R</code></p>
<p><strong>Implementation:</strong> Five per-stage data structures on the Scheduler instance (all reset by <code>start_stage()</code>):</p>
<table class="table"><colgroup><col width="33%"><col width="33%"><col width="33%"></colgroup><thead><tr class="header"><th>Structure</th>
<th>Type</th>
<th>Purpose</th>
</tr></thead><tbody><tr class="odd"><td><code>runtime_map</code></td>
<td><code>fastmap</code></td>
<td>States not yet dependency-cleared; keyed by state name → <code>AgentRuntime</code>
</td>
</tr><tr class="even"><td><code>ready_queue</code></td>
<td><code><a href="https://r-lib.github.io/fastmap/reference/fastqueue.html" class="external-link">fastmap::fastqueue</a></code></td>
<td>Dependency-resolved states sorted by priority (descending); FIFO within same priority</td>
</tr><tr class="odd"><td><code>waiting_pool</code></td>
<td><code>fastmap</code></td>
<td>In-flight promises; keyed by state name → <code>list(runtime, promise)</code>
</td>
</tr><tr class="even"><td><code>completed_map</code></td>
<td><code>fastmap</code></td>
<td>Finished states; keyed by state name → <code>list(policy, agent, attempt, attachment_id, status)</code> where status ∈ {“finished”, “errored”, “skipped”}</td>
</tr><tr class="odd"><td><code>retry_map</code></td>
<td><code>fastmap</code></td>
<td>Failed states awaiting retry; keyed by state name → runtime summary</td>
</tr></tbody></table><p><strong>Dispatch cycle</strong> (event-driven via <code>advance()</code>):</p>
<pre><code>init_stage(stage)
  └→ builds runtime_map from manifest
  └→ enqueue_runtime() seeds ready_queue

run_stage(stage) returns a promise
  └→ execute_runtime() kicks off first batch
  └→ each promise resolution → advance()
       └→ retry_runtime()    — re-creates runtimes from retry_map
       └→ enqueue_runtime()  — moves dep-cleared states to ready_queue
       └→ execute_runtime()  — dispatches up to max_concurrency
       └→ check completion   — resolves stage promise if done</code></pre>
<p><strong>Key methods:</strong> - <code>init_stage(stage)</code> — creates <code>AgentRuntime</code> for each state in the stage, populates <code>runtime_map</code> - <code>enqueue_runtime()</code> — checks <code>depends_on</code> resolution against <code>completed_map</code>; moves cleared states from <code>runtime_map</code> to <code>ready_queue</code> sorted by priority. Skips enqueuing when <code>self$draining</code> or <code>self$suspended</code>. - <code>execute_runtime()</code> — pops from <code>ready_queue</code> up to <code>max_concurrency - waiting_pool$size()</code> slots; creates promise chain with <code>onFulfilled</code>/<code>onRejected</code> callbacks; adds to <code>waiting_pool</code>. Implements critical-state priority barrier (see 4.5). - <code>advance()</code> — the event-driven driver; called from promise callbacks. Guards against cancellation (<code>.run_flag != .stage_flag</code>) and suspension. Detects stage completion when <code>get_incomplete_size() == 0</code> or draining with empty waiting pool. - <code>run_stage(stage)</code> — calls <code>start_stage()</code>, returns a <code><a href="https://rstudio.github.io/promises/reference/promise.html" class="external-link">promises::promise()</a></code> whose resolve/reject are stored in <code>private$.stage_resolve</code>/<code>.stage_reject</code> and settled by <code>advance()</code>.</p>
<p><strong>No <code>promise_race</code> needed:</strong> Each promise’s <code>.then()</code> callback calls <code>advance()</code> directly, which drives the next dispatch cycle. This is simpler and avoids the <code>promise_race</code> identification problem.</p>
</div>
<div class="section level3">
<h3 id="id_45-retry-on_failure-and-critical-priority-barrier-done">4.5 Retry, <code>on_failure</code>, and Critical Priority Barrier [Done]<a class="anchor" aria-label="anchor" href="#id_45-retry-on_failure-and-critical-priority-barrier-done"></a></h3>
<p><strong>Location:</strong> <code>R/class-scheduler.R</code></p>
<p><strong>Retry logic</strong> (in <code>execute_runtime()</code>’s <code>onFulfilled</code> callback and <code>retry_runtime()</code>): 1. <strong>State fails, retries remain, <code>on_failure</code> is <code>NA</code>:</strong> State is added to <code>retry_map</code>. <code>retry_runtime()</code> (called by <code>advance()</code>) creates a new <code>AgentRuntime</code> with <code>attempt + 1</code> and places it in <code>runtime_map</code>. <code>enqueue_runtime()</code> then moves it to <code>ready_queue</code> when dependencies are met. 2. <strong>State fails, retries remain, <code>on_failure</code> is set:</strong> The <code>on_failure</code> target is created as a new <code>AgentRuntime</code> in <code>runtime_map</code> (if not already completed or in-flight). The failed state is NOT retried — the redirect replaces retry. 3. <strong>State fails, retries exhausted, <code>critical = TRUE</code>:</strong> <code>self$suspend()</code> is called with the error and runtime summary. Suspend handler decides the action (see 4.2). 4. <strong>State fails, retries exhausted, <code>critical = FALSE</code>:</strong> Marked <code>"errored"</code> in <code>completed_map</code>. Downstream dependents proceed (they see the errored state as a satisfied dependency).</p>
<p><strong>Critical-state priority barrier</strong> (in <code>execute_runtime()</code>): - Before dispatching, all queued items are scanned. If any has <code>critical = TRUE</code>, only states at priority ≥ the highest critical state’s priority are dispatched. Lower-priority states are moved back to <code>runtime_map</code> for re-evaluation after the critical state settles. - This prevents lower-priority work from starting while a critical state is pending, since a critical failure could suspend the entire stage.</p>
<p><strong>Skipped vs Errored distinction:</strong> - <code>"errored"</code>: State was executed and failed (attachment exists with the error condition as result) - <code>"skipped"</code>: State was never executed (e.g., depends on a skipped or critical-failed state)</p>
<p><strong><code>skip_dependents()</code> (private):</strong> When a state is skipped (via suspend → skip action), recursively finds all same-stage states whose <code>depends_on</code> references the skipped state. Marks them as <code>"skipped"</code> in <code>completed_map</code>, removes them from <code>runtime_map</code> and <code>ready_queue</code>, and emits <code>"runtime.skipped"</code> events.</p>
</div>
<div class="section level3">
<h3 id="id_46-suspend-with-direct-call-dispatch-and-interactive-fallback-done">4.6 Suspend with Direct-Call Dispatch and Interactive Fallback [Done]<a class="anchor" aria-label="anchor" href="#id_46-suspend-with-direct-call-dispatch-and-interactive-fallback-done"></a></h3>
<p><strong>Location:</strong> <code>R/class-scheduler.R</code></p>
<p><strong>How <code>suspend()</code> works with the direct-call event system:</strong></p>
<p>When <code>suspend()</code> is called (from <code>execute_runtime()</code>’s promise callback after a critical state exhausts retries): 1. Sets <code>self$suspended = TRUE</code>, captures <code>suspend_info</code> 2. Logs the error with full traceback 3. Calls <code>self$dispatch_event(type = "suspend", ...)</code> which invokes <code>EventDispatcher$emit()</code> — iterates handlers and returns the first non-NULL return value 4. If a registered handler returns an action string (e.g., <code>"skip"</code>, <code>"resume"</code>, <code>"abort"</code>, <code>"restart_stage"</code>), that value is captured 5. If <strong>no handler returns an action</strong> (<code>NULL</code>), falls through to: - <code><a href="https://rdrr.io/r/base/interactive.html" class="external-link">interactive()</a></code> → <code><a href="https://rdrr.io/r/utils/menu.html" class="external-link">utils::menu()</a></code> with 4 choices: Retry state, Skip, Abort, Restart stage - Non-interactive → <code>"abort"</code> 6. The chosen action is executed inline via <code>switch(action, ...)</code> (see 4.2 for action details)</p>
<p><strong>For tests/CI — register a listener:</strong></p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">scheduler</span><span class="op">$</span><span class="fu">on</span><span class="op">(</span><span class="st">"suspend"</span>, <span class="kw">function</span><span class="op">(</span><span class="va">event</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="st">"skip"</span>  <span class="co"># or "abort", "resume", "restart_stage"</span></span>
<span><span class="op">}</span><span class="op">)</span></span>
<span><span class="va">scheduler</span><span class="op">$</span><span class="fu">start</span><span class="op">(</span><span class="op">)</span>  <span class="co"># no wrapping needed, no blocking menu</span></span></code></pre></div>
<p><strong>Key difference from original plan:</strong> No conditions, no restarts, no <code>$wrap()</code>. The handler return value is the action, not <code><a href="https://rdrr.io/r/base/conditions.html" class="external-link">invokeRestart()</a></code>. This is simpler and compatible with <code><a href="https://coro.r-lib.org/reference/async.html" class="external-link">coro::async</a></code>.</p>
</div>
<div class="section level3">
<h3 id="id_47-clone-chat-for-async-isolation-done">4.7 Clone Chat for Async Isolation [Done]<a class="anchor" aria-label="anchor" href="#id_47-clone-chat-for-async-isolation-done"></a></h3>
<p><strong>Location:</strong> <code>R/generic-as_agent.R</code></p>
<p><strong>Implementation:</strong> 1. Inside <code>agent_fun</code> (the closure created by <code>as_agent_from_chat</code>), the chat is <strong>always</strong> deep-cloned at the top: <code>r    chat &lt;- chat$clone(deep = TRUE)</code> 2. This ensures each execution gets its own <code>Chat</code> instance with independent conversation state, system prompt, and tool bindings — whether sync or async. 3. The clone happens unconditionally (not gated on <code>runtime$status</code>) to guarantee isolation in all modes and prevent subtle state leakage between retries.</p>
</div>
<div class="section level3">
<h3 id="id_48-final-states-drain-pool-done">4.8 <code>final</code> States Drain Pool [Done]<a class="anchor" aria-label="anchor" href="#id_48-final-states-drain-pool-done"></a></h3>
<p><strong>Location:</strong> <code>R/class-scheduler.R</code></p>
<p><strong>Implementation:</strong> 1. When a <code>final = TRUE</code> state’s promise resolves successfully, <code>self$draining</code> is set to <code>TRUE</code> and the <code>ready_queue</code> is cleared 2. <code>enqueue_runtime()</code> and <code>execute_runtime()</code> check <code>self$draining</code> and skip all work when <code>TRUE</code> 3. <code>advance()</code> detects drain completion when <code>self$draining == TRUE</code> and <code>waiting_pool$size() == 0</code> — it then clears remaining items in <code>runtime_map</code>/<code>ready_queue</code>/<code>retry_map</code> and resolves the stage promise 4. In-flight promises in the waiting pool are allowed to finish; their results are recorded normally</p>
<p><strong>Rationale:</strong> Promise cancellation is complex and error-prone. Letting in-flight work complete is simpler and the results may be useful for debugging.</p>
</div>
<div class="section level3">
<h3 id="id_49-edge-cases-and-potential-bugs">4.9 Edge Cases and Potential Bugs<a class="anchor" aria-label="anchor" href="#id_49-edge-cases-and-potential-bugs"></a></h3>
<p>The following issues were identified during review. They are documented here for discussion before fixing.</p>
<div class="section level4">
<h4 id="bug-1-onrejected-in-execute_runtime-doesnt-clean-up-waiting-pool">Bug 1: <code>onRejected</code> in <code>execute_runtime()</code> doesn’t clean up waiting pool<a class="anchor" aria-label="anchor" href="#bug-1-onrejected-in-execute_runtime-doesnt-clean-up-waiting-pool"></a></h4>
<p><strong>Location:</strong> <code>R/class-scheduler.R</code>, <code>execute_runtime()</code> promise chain</p>
<p><strong>Issue:</strong> <code>AgentRuntime$run_async()</code> catches agent errors internally (in <code>onFulfilled</code>/<code>onRejected</code> of the inner promise chain) and always calls <code>.record_result()</code>. This means the outer <code>.then()</code> in <code>execute_runtime()</code> always receives <code>onFulfilled</code>. However, if <code>.record_result()</code> itself throws (e.g., disk full, SQLite error, <code>agent@describe()</code> throws), the outer <code>onRejected</code> fires — and it only calls <code>self$advance()</code> without removing the state from <code>waiting_pool</code> or recording it in <code>completed_map</code>. The state effectively vanishes from all maps, causing the stage to never complete (it hangs waiting for an item that will never resolve).</p>
<p><strong>Fix:</strong> The <code>onRejected</code> callback should: 1. Remove the state from <code>waiting_pool</code> 2. Mark it as <code>"errored"</code> in <code>completed_map</code> 3. Then call <code>self$advance()</code></p>
</div>
<div class="section level4">
<h4 id="bug-2-on_failure-target-with-unsatisfied-dependencies-can-deadlock">Bug 2: <code>on_failure</code> target with unsatisfied dependencies can deadlock<a class="anchor" aria-label="anchor" href="#bug-2-on_failure-target-with-unsatisfied-dependencies-can-deadlock"></a></h4>
<p><strong>Location:</strong> <code>R/class-scheduler.R</code>, <code>execute_runtime()</code> on_failure redirect</p>
<p><strong>Issue:</strong> When <code>on_failure</code> fires, the target state is added to <code>runtime_map</code> with a fresh <code>AgentRuntime</code>. But <code>enqueue_runtime()</code> checks the target’s <code>depends_on</code> — if the target has unmet dependencies (other than the failed state), it will stay blocked in <code>runtime_map</code> indefinitely, preventing the stage from completing.</p>
<p><strong>Note:</strong> The code already has a TODO comment: “need to check if the on_failure depends on the current runtime when manifest is created”. This validation should be added to the <code>Manifest</code> validator (Phase 5).</p>
<p><strong>Fix options:</strong> - Add manifest validation: <code>on_failure</code> targets must not have <code>depends_on</code> entries that could be unsatisfied when the source state fails (e.g., deps must be a subset of the source state’s own deps, or deps on earlier stages only) - Or: at redirect time, automatically satisfy the failed state’s dependency in <code>completed_map</code> (it’s already there as errored) — but the target may have <em>other</em> deps too</p>
</div>
<div class="section level4">
<h4 id="bug-3-non-critical-exhausted-states-satisfy-downstream-dependencies-silently">Bug 3: Non-critical exhausted states satisfy downstream dependencies silently<a class="anchor" aria-label="anchor" href="#bug-3-non-critical-exhausted-states-satisfy-downstream-dependencies-silently"></a></h4>
<p><strong>Location:</strong> <code>R/class-scheduler.R</code>, <code>execute_runtime()</code> failure handling</p>
<p><strong>Issue:</strong> When a non-critical state exhausts retries, it’s marked <code>"errored"</code> in <code>completed_map</code>. This <em>satisfies</em> downstream <code>depends_on</code> checks in <code>enqueue_runtime()</code>. Dependents are enqueued and execute, receiving the errored state’s attachment (which contains the error condition as <code>result</code>). The dependent agent may not expect or handle an error object as input.</p>
<p><strong>Assessment:</strong> This is documented design (“Dependents receive the error — the agent function can inspect it”), but it’s a footgun. Function agents using <code>accessibility = "explicit"</code> will receive an error condition object as their parameter value, which will likely cause a secondary failure. Chat agents receive a textual <code><a href="reference/mcp_describe.html">mcp_describe()</a></code> of the error, which is more graceful.</p>
<p><strong>Potential improvements:</strong> - Add <code>skip_dependents()</code> call for non-critical exhaustion (opt-in via a policy flag?) - Or: document clearly that agents downstream of non-critical states should handle error inputs</p>
</div>
<div class="section level4">
<h4 id="bug-4-start-return-value-is-unclear">Bug 4: <code>start()</code> return value is unclear<a class="anchor" aria-label="anchor" href="#bug-4-start-return-value-is-unclear"></a></h4>
<p><strong>Location:</strong> <code>R/class-scheduler.R</code>, <code><a href="https://rdrr.io/r/stats/start.html" class="external-link">start()</a></code></p>
<p><strong>Issue:</strong> <code><a href="https://rdrr.io/r/stats/start.html" class="external-link">start()</a></code> uses <code><a href="https://coro.r-lib.org/reference/async.html" class="external-link">coro::async</a></code> internally and calls <code>impl()$then(onFulfilled, onRejected)</code>. The <code>$then()</code> returns a promise, but <code><a href="https://rdrr.io/r/stats/start.html" class="external-link">start()</a></code> doesn’t explicitly return it — the promise is returned implicitly (last expression). The <code>@return</code> docs say “A promise that resolves when all stages complete,” which is correct, but the <code>$then()</code> wrapping means any rejection is already handled (printed as <code><a href="https://rdrr.io/r/base/message.html" class="external-link">message()</a></code>), so the returned promise always resolves. Callers who chain <code>.then(onRejected = ...)</code> on the return value will never see failures.</p>
<p><strong>Assessment:</strong> Minor — the current pattern (print + resolve) is fine for interactive use. For programmatic use, callers should use <code>scheduler$on("suspend", ...)</code> to handle failures.</p>
<hr></div>
</div>
</div>
<div class="section level2">
<h2 id="phase-5-manifest-validation-for-async">Phase 5: Manifest Validation for Async<a class="anchor" aria-label="anchor" href="#phase-5-manifest-validation-for-async"></a></h2>
<p><strong>Why:</strong> Prevent invalid configurations that cause undefined behavior in async mode.</p>
<div class="section level3">
<h3 id="id_51-critical-and-final-state-validation">5.1 Critical and Final State Validation<a class="anchor" aria-label="anchor" href="#id_51-critical-and-final-state-validation"></a></h3>
<p><strong>Location:</strong> <code>R/class-manifest.R</code> (Manifest validator)</p>
<p><strong>Steps:</strong> 1. Validate that <code>critical = TRUE</code> states have unique priority within their stage — prevents concurrent critical states where both could fail simultaneously 2. Validate that <code>final = TRUE</code> states have unique priority within their stage — prevents race between two final states 3. Error at manifest construction time with clear message</p>
</div>
<div class="section level3">
<h3 id="id_52-dependency-validation-done">5.2 Dependency Validation [Done]<a class="anchor" aria-label="anchor" href="#id_52-dependency-validation-done"></a></h3>
<p>Already implemented in <code>Manifest</code> validator: - <code>depends_on</code> references must exist in manifest - Same-stage deps must have strictly higher priority (guarantees execution order) - Circular dependency detection</p>
<hr></div>
</div>
<div class="section level2">
<h2 id="phase-6-error-handling--timeouts">Phase 6: Error Handling &amp; Timeouts<a class="anchor" aria-label="anchor" href="#phase-6-error-handling--timeouts"></a></h2>
<div class="section level3">
<h3 id="id_61-add-timeout-property-to-statepolicy">6.1 Add <code>timeout</code> Property to StatePolicy<a class="anchor" aria-label="anchor" href="#id_61-add-timeout-property-to-statepolicy"></a></h3>
<p><strong>Location:</strong> <code>R/class-policystate.R</code></p>
<p><strong>Steps:</strong> 1. Add property: <code>timeout = S7::new_property(class = S7::class_integer, default = NA_integer_)</code> (seconds) 2. In <code>run_stage_async</code> dispatch, wrap the runtime promise with <code><a href="https://rstudio.github.io/promises/reference/promise_all.html" class="external-link">promises::promise_race()</a></code>: <code>r    if (!is.na(policy@timeout)) {      state_promise &lt;- promises::promise_race(        runtime$run_async(),        promises::promise(function(resolve, reject) {          later::later(            function() reject(simpleError("Timeout after N seconds")),            delay = policy@timeout          )        })      )    } else {      state_promise &lt;- runtime$run_async()    }</code> 3. Timeout rejection is handled as a normal failure — retry logic applies</p>
</div>
<div class="section level3">
<h3 id="id_62-partial-failure-policy">6.2 Partial Failure Policy<a class="anchor" aria-label="anchor" href="#id_62-partial-failure-policy"></a></h3>
<p><strong>Decision:</strong> Default to optimistic — continue dispatching unless the failed state is <code>critical</code>.</p>
<ul><li>Non-critical failure: state is recorded as <code>"errored"</code> in <code>completed_set</code> with the error condition as its result value. Dependents receive the error condition and can inspect it.</li>
<li>Critical failure: <code>suspend()</code> is called. The suspend handler (interactive or programmatic) decides: resume, skip, or abort.</li>
<li>No separate configuration needed — the <code>critical</code> flag on <code>StatePolicy</code> already provides per-state control.</li>
</ul><hr></div>
</div>
<div class="section level2">
<h2 id="resolved-design-questions">Resolved Design Questions<a class="anchor" aria-label="anchor" href="#resolved-design-questions"></a></h2>
<div class="section level3">
<h3 id="q1-on_failure-with-different-priorities--resolved">Q1: <code>on_failure</code> with Different Priorities → Resolved<a class="anchor" aria-label="anchor" href="#q1-on_failure-with-different-priorities--resolved"></a></h3>
<p>The queue model eliminates priority-tier boundaries. <code>on_failure</code> targets are simply enqueued into the ready queue and dispatched when their dependencies are met. Priority only affects ordering within the queue, not grouping.</p>
<ul><li>
<strong>Same priority:</strong> Safe — the <code>on_failure</code> target is enqueued and dispatched in the next loop iteration. If it’s already running (was dispatched concurrently), skip the jump and log a warning.</li>
<li>
<strong>Higher priority (already ran):</strong> The target is re-enqueued and dispatched immediately (nothing blocks it). This is a re-execution, not a re-visit of a priority tier.</li>
<li>
<strong>Lower priority (hasn’t run yet):</strong> Natural fit — it runs when dispatched from the queue in priority order.</li>
</ul></div>
<div class="section level3">
<h3 id="q2-partial-parallel-failure--resolved">Q2: Partial Parallel Failure → Resolved<a class="anchor" aria-label="anchor" href="#q2-partial-parallel-failure--resolved"></a></h3>
<p>Default optimistic: continue unless <code>critical</code>. See Phase 6.2.</p>
</div>
<div class="section level3">
<h3 id="q3-result-ordering--resolved">Q3: Result Ordering → Resolved<a class="anchor" aria-label="anchor" href="#q3-result-ordering--resolved"></a></h3>
<p>Accepted as expected async behavior. <code>list_attachments()</code> returns results ordered by <code>created_at</code> timestamp (actual completion time). Priority order is recorded in the policy metadata for reference but does not govern result ordering.</p>
<hr></div>
</div>
<div class="section level2">
<h2 id="testing-strategy">Testing Strategy<a class="anchor" aria-label="anchor" href="#testing-strategy"></a></h2>
<div class="section level3">
<h3 id="unit-tests">Unit Tests<a class="anchor" aria-label="anchor" href="#unit-tests"></a></h3>
<ul><li>
<code>tests/testthat/test-event-dispatcher.R</code> — EventDispatcher: <code>$on()</code>, <code>$off()</code>, <code>$emit()</code>, <code>$wrap()</code>, condition propagation, restart invocation</li>
<li>
<code>tests/testthat/test-lifecycle-conditions.R</code> — Condition constructors, class hierarchy, <code><a href="https://testthat.r-lib.org/reference/expect_error.html" class="external-link">testthat::expect_condition()</a></code> integration</li>
<li>
<code>tests/testthat/test-async-scheduler.R</code> — Queue + pool dispatch with mock agents</li>
<li>
<code>tests/testthat/test-async-dependencies.R</code> — <code>depends_on</code> blocks dispatch until dependency completes</li>
<li>
<code>tests/testthat/test-async-suspend.R</code> — Suspend via condition system: listener-invoked restarts (resume/skip/abort/restart_stage), interactive fallback, no-listener default</li>
<li>
<code>tests/testthat/test-async-retry.R</code> — Retry and <code>on_failure</code> re-enqueue in async mode</li>
<li>
<code>tests/testthat/test-async-final.R</code> — <code>final = TRUE</code> drains pool and stops dispatch</li>
<li>
<code>tests/testthat/test-async-timeout.R</code> — Timeout via <code>promise_race</code>
</li>
</ul></div>
<div class="section level3">
<h3 id="integration-tests">Integration Tests<a class="anchor" aria-label="anchor" href="#integration-tests"></a></h3>
<ul><li>Concurrent LLM calls complete faster than sequential (wallclock comparison)</li>
<li>
<code>AgentRuntime</code> isolation: concurrent agents don’t corrupt each other’s Chat state</li>
<li>SQLite <code>AttachmentIndex</code> handles concurrent writes without corruption</li>
</ul></div>
<div class="section level3">
<h3 id="mock-agent-helpers">Mock Agent Helpers<a class="anchor" aria-label="anchor" href="#mock-agent-helpers"></a></h3>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Async mock that simulates I/O delay</span></span>
<span><span class="va">mock_async_agent</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">delay_secs</span> <span class="op">=</span> <span class="fl">0.1</span>, <span class="va">result</span> <span class="op">=</span> <span class="st">"ok"</span>, <span class="va">fail</span> <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="reference/as_agent.html">as_agent</a></span><span class="op">(</span><span class="kw">function</span><span class="op">(</span><span class="va">runtime</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="va">p</span> <span class="op">&lt;-</span> <span class="fu">promises</span><span class="fu">::</span><span class="fu"><a href="https://rstudio.github.io/promises/reference/promise.html" class="external-link">promise</a></span><span class="op">(</span><span class="kw">function</span><span class="op">(</span><span class="va">resolve</span>, <span class="va">reject</span><span class="op">)</span> <span class="op">{</span></span>
<span>      <span class="fu">later</span><span class="fu">::</span><span class="fu"><a href="https://later.r-lib.org/reference/later.html" class="external-link">later</a></span><span class="op">(</span><span class="kw">function</span><span class="op">(</span><span class="op">)</span> <span class="op">{</span></span>
<span>        <span class="kw">if</span> <span class="op">(</span><span class="va">fail</span><span class="op">)</span> <span class="fu">reject</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/conditions.html" class="external-link">simpleError</a></span><span class="op">(</span><span class="st">"mock failure"</span><span class="op">)</span><span class="op">)</span></span>
<span>        <span class="kw">else</span> <span class="fu">resolve</span><span class="op">(</span><span class="va">result</span><span class="op">)</span></span>
<span>      <span class="op">}</span>, delay <span class="op">=</span> <span class="va">delay_secs</span><span class="op">)</span></span>
<span>    <span class="op">}</span><span class="op">)</span></span>
<span>    <span class="kw"><a href="https://rdrr.io/r/base/function.html" class="external-link">return</a></span><span class="op">(</span><span class="va">p</span><span class="op">)</span>  <span class="co"># run_async will await this</span></span>
<span>  <span class="op">}</span>, id <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste0</a></span><span class="op">(</span><span class="st">"mock_"</span>, <span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample.int</a></span><span class="op">(</span><span class="fl">1e6</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<hr></div>
</div>
<div class="section level2">
<h2 id="migration-path">Migration Path<a class="anchor" aria-label="anchor" href="#migration-path"></a></h2>
<div class="section level3">
<h3 id="backward-compatibility">Backward Compatibility<a class="anchor" aria-label="anchor" href="#backward-compatibility"></a></h3>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Sync mode (default - unchanged)</span></span>
<span><span class="va">scheduler</span> <span class="op">&lt;-</span> <span class="va"><a href="reference/Scheduler.html">Scheduler</a></span><span class="op">$</span><span class="fu">new</span><span class="op">(</span><span class="va">manifest</span>, <span class="va">agents</span><span class="op">)</span></span>
<span><span class="va">scheduler</span><span class="op">$</span><span class="fu">start</span><span class="op">(</span><span class="op">)</span>  <span class="co"># Blocking, sequential execution</span></span>
<span></span>
<span><span class="co"># With lifecycle listeners</span></span>
<span><span class="va">scheduler</span> <span class="op">&lt;-</span> <span class="va"><a href="reference/Scheduler.html">Scheduler</a></span><span class="op">$</span><span class="fu">new</span><span class="op">(</span><span class="va">manifest</span>, <span class="va">agents</span><span class="op">)</span></span>
<span><span class="va">scheduler</span><span class="op">$</span><span class="fu">on</span><span class="op">(</span><span class="st">"state_completed"</span>, <span class="kw">function</span><span class="op">(</span><span class="va">cond</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/cat.html" class="external-link">cat</a></span><span class="op">(</span><span class="st">"Done:"</span>, <span class="va">cond</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">state_name</span>, <span class="st">"\n"</span><span class="op">)</span></span>
<span><span class="op">}</span><span class="op">)</span></span>
<span><span class="va">scheduler</span><span class="op">$</span><span class="fu">on</span><span class="op">(</span><span class="st">"suspend"</span>, <span class="kw">function</span><span class="op">(</span><span class="va">cond</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/conditions.html" class="external-link">invokeRestart</a></span><span class="op">(</span><span class="st">"tricobbler_skip"</span><span class="op">)</span>  <span class="co"># auto-skip for CI</span></span>
<span><span class="op">}</span><span class="op">)</span></span>
<span><span class="va">scheduler</span><span class="op">$</span><span class="fu">start</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Async mode (opt-in)</span></span>
<span><span class="va">scheduler</span> <span class="op">&lt;-</span> <span class="va"><a href="reference/Scheduler.html">Scheduler</a></span><span class="op">$</span><span class="fu">new</span><span class="op">(</span><span class="va">manifest</span>, <span class="va">agents</span>, max_concurrency <span class="op">=</span> <span class="fl">4L</span><span class="op">)</span></span>
<span><span class="va">promise</span> <span class="op">&lt;-</span> <span class="va">scheduler</span><span class="op">$</span><span class="fu">start_async</span><span class="op">(</span><span class="op">)</span>  <span class="co"># Returns promise</span></span>
<span><span class="co"># Run the event loop (in interactive R or plumber/shiny):</span></span>
<span><span class="fu">coro</span><span class="fu">::</span><span class="fu"><a href="https://coro.r-lib.org/reference/async_collect.html" class="external-link">async_collect</a></span><span class="op">(</span><span class="va">promise</span><span class="op">)</span></span>
<span><span class="co"># Or in a script:</span></span>
<span><span class="fu">promises</span><span class="fu">::</span><span class="fu"><a href="https://rstudio.github.io/promises/reference/promise_all.html" class="external-link">promise_all</a></span><span class="op">(</span><span class="va">promise</span><span class="op">)</span></span>
<span><span class="fu">later</span><span class="fu">::</span><span class="fu"><a href="https://later.r-lib.org/reference/run_now.html" class="external-link">run_now</a></span><span class="op">(</span><span class="op">)</span>  <span class="co"># Drive the event loop</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="deprecation-schedule">Deprecation Schedule<a class="anchor" aria-label="anchor" href="#deprecation-schedule"></a></h3>
<ol style="list-style-type: decimal"><li>
<strong>v1.x:</strong> <code>accessibility = "all"</code> / <code>"logs"</code> continue working, emit deprecation warning in async mode</li>
<li>
<strong>v2.x:</strong> Require <code>accessibility = "explicit"</code> with <code>depends_on</code> for agents that read previous results in async mode</li>
</ol></div>
</div>
</div>

  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p>Developed by Dipterix Wang.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.2.0.</p>
</div>

    </footer></div>





  </body></html>

